## Overview

Add two related type classes for type-safe schema evolution:

1. **`Into[A, B]`**: One-way conversion from `A` to `B` with runtime validation
2. **`As[A, B]`**: Bidirectional conversion establishing a partial equivalence between `A` and `B`

Both type classes are automatically derived via macros that intelligently map fields using names, positions, and types, with support for validation, coercion, and schema evolution patterns.

---

## Type Class Definitions

### Into[A, B] - One-Way Conversion

```scala
trait Into[-A, +B] {
  def into(input: A): Either[SchemaError, B]
}
```

**Purpose**: Convert from source type `A` to target type `B`, potentially failing at runtime when validation constraints cannot be satisfied.

**Use Cases**:
- Migrating between schema versions
- Converting between equivalent representations
- Validating conversions with opaque types
- Transforming external data into internal models

### As[A, B] - Bidirectional Conversion

```scala
trait As[A, B] {
  def into(input: A): Either[SchemaError, B]
  def from(input: B): Either[SchemaError, A]
}
```

**Purpose**: Establish a partial equivalence between types `A` and `B` where conversion can fail in either direction due to runtime validation.

**Use Cases**:
- Isomorphic schema versions
- Equivalent representations (e.g., case class ↔ tuple)
- Reversible transformations with runtime validation
- Round-trip serialization/deserialization

**Relationship**: `As[A, B]` implies both `Into[A, B]` and `Into[B, A]` exist, but with the additional guarantee that both conversions use compatible mapping logic and can round-trip (subject to runtime validation).

**Note**: `SchemaError` is composable, allowing multiple validation failures to be combined into a single error.

---

## Core Conversion Rules

### Field Mapping Algorithm

The macro establishes field mappings using three attributes:
1. **Field name** (identifier in source code)
2. **Field position** (ordinal position in declaration)
3. **Field type** (including coercible types)

**Priority for disambiguation:**
1. **Exact match**: Same name + same type
2. **Name match with coercion**: Same name + coercible type
3. **Unique type match**: Type appears only once in both source and target
4. **Position + unique type**: Positional correspondence with unambiguous type
5. **Fallback**: If no unambiguous mapping exists, derivation fails at compile-time

### Mapping Examples

#### Unambiguous by Unique Types
```scala
case class Person(name: String, age: Int, active: Boolean)
case class User(username: String, yearsOld: Int, enabled: Boolean)

// Success: Each type appears exactly once
// Mapping: String→String, Int→Int, Boolean→Boolean
```

#### Unambiguous by Names
```scala
case class Point(x: Int, y: Int)
case class Coord(y: Int, x: Int)

// Success: Names uniquely identify despite reordering
// Mapping: x→x, y→y
```

#### Ambiguous - Compile Failure
```scala
case class Dimensions(width: Int, height: Int)
case class Measurements(first: Int, second: Int)

// COMPILE ERROR: Cannot determine mapping
// Both Int types, different names, ambiguous positional match
```

#### Disambiguation by Position (Tuples)
```scala
case class RGB(r: Int, g: Int, b: Int)
type ColorTuple = (Int, Int, Int)

// Success: Position disambiguates
// Mapping: r→_1, g→_2, b→_3
```

---

## Supported Conversions

### 1. Product Types (Records)

#### Case Class to Case Class
```scala
case class PersonV1(name: String, age: Int)
case class PersonV2(fullName: String, age: Int)

// Success if 'name' is unique String in V1 and 'fullName' is unique String in V2
Into[PersonV1, PersonV2].into(PersonV1("Alice", 30))
// => Right(PersonV2("Alice", 30))
```

#### Case Class to Tuple
```scala
case class Point(x: Double, y: Double)

Into[Point, (Double, Double)].into(Point(1.0, 2.0))
// => Right((1.0, 2.0))
```

#### Tuple to Case Class
```scala
case class RGB(red: Int, green: Int, blue: Int)

Into[(Int, Int, Int), RGB].into((255, 128, 64))
// => Right(RGB(255, 128, 64))
```

#### Tuple to Tuple
```scala
Into[(Int, String), (Long, String)].into((42, "hello"))
// => Right((42L, "hello"))
```

### 2. Coproduct Types (Sum Types)

#### Sealed Trait to Sealed Trait (by name)
```scala
sealed trait Color
case object Red extends Color
case object Blue extends Color

sealed trait Hue
case object Red extends Hue
case object Blue extends Hue

Into[Color, Hue].into(Red)
// => Right(Red)
```

#### Sealed Trait to Sealed Trait (by signature)
```scala
sealed trait EventV1
case class Created(id: String, ts: Long) extends EventV1
case class Deleted(id: String) extends EventV1

sealed trait EventV2
case class Spawned(id: String, ts: Long) extends EventV2
case class Removed(id: String) extends EventV2

Into[EventV1, EventV2].into(Created("abc", 123L))
// => Right(Spawned("abc", 123L))
// Matched by constructor signature (String, Long)
```

#### Enum to Enum (Scala 3)
```scala
enum Status:
  case Active, Inactive, Suspended

enum State:
  case Active, Inactive, Suspended

Into[Status, State].into(Status.Active)
// => Right(State.Active)
```

#### ADT with Payload Conversion
```scala
sealed trait ResultV1
case class Success(value: Int) extends ResultV1
case class Failure(msg: String) extends ResultV1

sealed trait ResultV2
case class Success(value: Long) extends ResultV2
case class Failure(msg: String) extends ResultV2

Into[ResultV1, ResultV2].into(Success(42))
// => Right(Success(42L))
// Field type coercion within matched case
```

### 3. Primitive Type Coercions

#### Numeric Widening (Lossless)
```scala
Into[Byte, Short].into(42.toByte)    // => Right(42.toShort)
Into[Short, Int].into(1000.toShort)  // => Right(1000)
Into[Int, Long].into(100000)         // => Right(100000L)
Into[Float, Double].into(3.14f)      // => Right(3.14)
```

#### Numeric Narrowing (with Runtime Validation)
```scala
Into[Long, Int].into(42L)
// => Right(42)

Into[Long, Int].into(3000000000L)
// => Left(SchemaError("Value 3000000000 exceeds Int.MaxValue"))

Into[Double, Float].into(3.14)
// => Right(3.14f)

Into[Double, Float].into(1e100)
// => Left(SchemaError("Value 1.0E100 exceeds Float.MaxValue"))
```

#### Collection Element Coercion
```scala
Into[List[Int], List[Long]].into(List(1, 2, 3))
// => Right(List(1L, 2L, 3L))

Into[Vector[Float], Vector[Double]].into(Vector(1.5f, 2.5f))
// => Right(Vector(1.5, 2.5))

Into[Set[Short], Set[Int]].into(Set(10.toShort, 20.toShort))
// => Right(Set(10, 20))

Into[List[Long], List[Int]].into(List(42L, 3000000000L))
// => Left(SchemaError("Value 3000000000 exceeds Int.MaxValue"))
```

#### Nested Collection Coercion
```scala
Into[List[List[Int]], List[List[Long]]].into(List(List(1, 2), List(3, 4)))
// => Right(List(List(1L, 2L), List(3L, 4L)))
```

#### Map Key/Value Coercion
```scala
Into[Map[Int, Float], Map[Long, Double]].into(Map(1 -> 1.5f, 2 -> 2.5f))
// => Right(Map(1L -> 1.5, 2L -> 2.5))

Into[Map[Long, String], Map[Int, String]].into(Map(42L -> "a", 3000000000L -> "b"))
// => Left(SchemaError("Key 3000000000 exceeds Int.MaxValue"))
```

#### Option Type Coercion
```scala
Into[Option[Int], Option[Long]].into(Some(42))
// => Right(Some(42L))

Into[Option[Int], Option[Long]].into(None)
// => Right(None)

Into[Option[Long], Option[Int]].into(Some(3000000000L))
// => Left(SchemaError("Value 3000000000 exceeds Int.MaxValue"))
```

#### Either Type Coercion
```scala
Into[Either[String, Int], Either[String, Long]].into(Right(42))
// => Right(Right(42L))

Into[Either[Int, String], Either[Long, String]].into(Left(100))
// => Right(Left(100L))
```

### 4. Collection Type Conversions

#### Between Standard Collection Types
```scala
Into[List[Int], Vector[Int]].into(List(1, 2, 3))
// => Right(Vector(1, 2, 3))

Into[Vector[String], List[String]].into(Vector("a", "b", "c"))
// => Right(List("a", "b", "c"))

Into[Array[Int], List[Int]].into(Array(1, 2, 3))
// => Right(List(1, 2, 3))

Into[List[Int], Array[Int]].into(List(1, 2, 3))
// => Right(Array(1, 2, 3))

Into[Seq[Int], List[Int]].into(Seq(1, 2, 3))
// => Right(List(1, 2, 3))

Into[List[Int], Seq[Int]].into(List(1, 2, 3))
// => Right(Seq(1, 2, 3))
```

#### Set Conversions (Order-Preserving Collections to Set)
```scala
Into[List[Int], Set[Int]].into(List(1, 2, 2, 3))
// => Right(Set(1, 2, 3))
// Note: Duplicates are removed

Into[Vector[String], Set[String]].into(Vector("a", "b", "a"))
// => Right(Set("a", "b"))
```

#### Set to Order-Preserving Collections
```scala
Into[Set[Int], List[Int]].into(Set(3, 1, 2))
// => Right(List(1, 2, 3))
// Note: Order is determined by Set's iteration order

Into[Set[String], Vector[String]].into(Set("c", "a", "b"))
// => Right(Vector("a", "b", "c"))
```

#### Combined Element and Collection Type Conversion
```scala
Into[List[Int], Vector[Long]].into(List(1, 2, 3))
// => Right(Vector(1L, 2L, 3L))

Into[Array[Short], List[Int]].into(Array(10.toShort, 20.toShort))
// => Right(List(10, 20))

Into[Set[Int], List[Long]].into(Set(1, 2, 3))
// => Right(List(1L, 2L, 3L))
```

#### Nested Collection Type Conversions
```scala
Into[List[Vector[Int]], Vector[List[Long]]].into(List(Vector(1, 2), Vector(3, 4)))
// => Right(Vector(List(1L, 2L), List(3L, 4L)))
```

### 5. Structural Types

#### Structural Type Targets (Scala 3 with Selectable)
```scala
case class Point(x: Int, y: Int)
type Coord = { def x: Int; def y: Int }

Into[Point, Coord].into(Point(5, 10))
// => Right(<structural instance with x=5, y=10>)
```

#### Structural Type Targets (Scala 2 with Dynamic)
```scala
case class Person(name: String, age: Int)
type Record = { def name: String; def age: Int }

Into[Person, Record].into(Person("Alice", 30))
// => Right(<dynamic instance with name="Alice", age=30>)
```

#### Structural Type Sources
```scala
type PersonLike = { def name: String; def age: Int }
case class User(name: String, age: Int)

val personLike: PersonLike = ??? // some structural instance
Into[PersonLike, User].into(personLike)
// => Right(User("Alice", 30))
```

### 6. Schema Evolution Patterns

#### Adding Optional Fields
```scala
case class UserV1(id: String, name: String)
case class UserV2(id: String, name: String, email: Option[String])

Into[UserV1, UserV2].into(UserV1("123", "Alice"))
// => Right(UserV2("123", "Alice", None))
```

#### Removing Optional Fields
```scala
case class UserV2(id: String, name: String, email: Option[String])
case class UserV1(id: String, name: String)

Into[UserV2, UserV1].into(UserV2("123", "Alice", Some("alice@example.com")))
// => Right(UserV1("123", "Alice"))
// email field is dropped
```

#### Adding Required Fields with Defaults (Scala 3)
```scala
case class ProductV1(name: String, price: Double)
case class ProductV2(name: String, price: Double, available: Boolean = true)

Into[ProductV1, ProductV2].into(ProductV1("Widget", 19.99))
// => Right(ProductV2("Widget", 19.99, true))
```

#### Field Reordering
```scala
case class PersonV1(name: String, age: Int, email: String)
case class PersonV2(email: String, name: String, age: Int)

Into[PersonV1, PersonV2].into(PersonV1("Alice", 30, "alice@example.com"))
// => Right(PersonV2("alice@example.com", "Alice", 30))
```

#### Field Renaming (with unique types)
```scala
case class PersonV1(fullName: String, yearOfBirth: Int)
case class PersonV2(name: String, birthYear: Int)

Into[PersonV1, PersonV2].into(PersonV1("Alice Smith", 1990))
// => Right(PersonV2("Alice Smith", 1990))
```

#### Type Refinement
```scala
case class ConfigV1(port: Int, timeout: Int)
case class ConfigV2(port: Int, timeout: Long)

Into[ConfigV1, ConfigV2].into(ConfigV1(8080, 30))
// => Right(ConfigV2(8080, 30L))
```

### 7. Nested Conversions

#### Nested Products
```scala
case class AddressV1(street: String, zip: Int)
case class PersonV1(name: String, address: AddressV1)

case class AddressV2(street: String, zip: Long)
case class PersonV2(name: String, address: AddressV2)

Into[PersonV1, PersonV2].into(
  PersonV1("Alice", AddressV1("Main St", 12345))
)
// => Right(PersonV2("Alice", AddressV2("Main St", 12345L)))
```

#### Nested Coproducts
```scala
sealed trait Inner
case class A(x: Int) extends Inner
case class B(y: String) extends Inner

sealed trait Outer
case class Container(inner: Inner, label: String) extends Outer

// Similar target types with Long instead of Int
sealed trait InnerV2
case class A(x: Long) extends InnerV2
case class B(y: String) extends InnerV2

sealed trait OuterV2
case class Container(inner: InnerV2, label: String) extends OuterV2

Into[Outer, OuterV2].into(Container(A(42), "test"))
// => Right(Container(A(42L), "test"))
```

#### Collections of Complex Types
```scala
case class PersonV1(name: String, age: Int)
case class PersonV2(name: String, age: Long)

Into[List[PersonV1], List[PersonV2]].into(
  List(PersonV1("Alice", 30), PersonV1("Bob", 25))
)
// => Right(List(PersonV2("Alice", 30L), PersonV2("Bob", 25L)))
```

#### Nested Collections with Type Conversions
```scala
case class DataV1(values: List[Vector[Int]])
case class DataV2(values: Vector[List[Long]])

Into[DataV1, DataV2].into(
  DataV1(List(Vector(1, 2), Vector(3, 4)))
)
// => Right(DataV2(Vector(List(1L, 2L), List(3L, 4L))))
```

---

## Special Type Support

### Opaque Types (Scala 3)

Opaque types with validation are fully supported. The macro generates runtime validation calls.

```scala
// Definition with validation
object Domain:
  opaque type Age = Int
  object Age:
    def apply(value: Int): Either[String, Age] =
      if value >= 0 && value <= 150 then Right(value)
      else Left(s"Invalid age: $value")
    
    def unsafe(value: Int): Age = value
    
    extension (age: Age)
      def toInt: Int = age

  opaque type Email = String
  object Email:
    def apply(value: String): Either[String, Email] =
      if value.contains("@") then Right(value)
      else Left(s"Invalid email: $value")
    
    extension (email: Email)
      def toString: String = email

import Domain._

// Usage
case class PersonV1(name: String, age: Int, email: String)
case class PersonV2(name: String, age: Age, email: Email)

Into[PersonV1, PersonV2].into(PersonV1("Alice", 30, "alice@example.com"))
// => Right(PersonV2("Alice", Age.unsafe(30), Email.unsafe("alice@example.com")))

Into[PersonV1, PersonV2].into(PersonV1("Alice", -5, "alice@example.com"))
// => Left(SchemaError("Age validation failed: Invalid age: -5"))

Into[PersonV1, PersonV2].into(PersonV1("Alice", 30, "invalid"))
// => Left(SchemaError("Email validation failed: Invalid email: invalid"))
```

**Macro Behavior**:
- Detects opaque type companion objects with `apply(underlying): Either[_, OpaqueType]` method
- Generates validation calls for each opaque type field
- Accumulates all validation errors using `SchemaError` composition
- Falls back to direct conversion if no validation method exists

### Newtype Libraries (Scala 2)

#### ZIO Prelude Newtypes (Built-in Support)

The macro includes hardcoded support for ZIO Prelude newtypes without requiring a compile-time dependency.

```scala
import zio.prelude._

// Definition with validation
object Domain {
  object Age extends Subtype[Int] {
    override def assertion = assert {
      Assertion.between(0, 150)
    }
  }
  type Age = Age.Type

  object Email extends Newtype[String] {
    override def assertion = assert {
      Assertion.matches(".*@.*")
    }
  }
  type Email = Email.Type
}

import Domain._

// Usage
case class PersonV1(name: String, age: Int, email: String)
case class PersonV2(name: String, age: Age, email: Email)

Into[PersonV1, PersonV2].into(PersonV1("Alice", 30, "alice@example.com"))
// => Right(PersonV2("Alice", Age(30), Email("alice@example.com")))

Into[PersonV1, PersonV2].into(PersonV1("Alice", 200, "invalid"))
// => Left(SchemaError("Validation failed: age: 200 is not between 0 and 150, email: invalid does not match .*@.*"))
```

**Macro Detection** (no ZIO Prelude dependency required):
```scala
// The macro detects ZIO Prelude newtypes by checking:
// 1. Type extends Newtype[A] or Subtype[A]
// 2. Companion object exists
// 3. Has apply/wrap method with validation

// Low-level AST matching in Scala 2 macro:
def isZIONewtype(tpe: Type): Boolean = {
  tpe.typeSymbol.fullName.startsWith("zio.prelude.Newtype") ||
  tpe.typeSymbol.fullName.startsWith("zio.prelude.Subtype")
}
```

#### Other Newtype Libraries

For other newtype libraries, users can provide explicit `Into` instances. The macro will use these instances when available.

```scala
// User-provided instance for their newtype library
implicit val stringToMyNewtype: Into[String, MyNewtype] = 
  new Into[String, MyNewtype] {
    def into(s: String): Either[SchemaError, MyNewtype] =
      MyNewtype.make(s).left.map(e => SchemaError(e.toString))
  }

// The macro will automatically use this instance
case class PersonV1(email: String)
case class PersonV2(email: MyNewtype)

Into[PersonV1, PersonV2].into(PersonV1("test@example.com"))
// Uses the user-provided instance automatically
```

### Validation Error Accumulation

When multiple validations fail, all errors are accumulated using `SchemaError` composition:

```scala
case class PersonV1(name: String, age: Int, email: String)
case class PersonV2(name: String, age: Age, email: Email)

Into[PersonV1, PersonV2].into(PersonV1("", -5, "invalid"))
// => Left(SchemaError(...)) // Combined error containing all validation failures
```

---

## As[A, B] Additional Requirements

For `As[A, B]` to be derivable, the bidirectional conversion must be **compatible**:

### Compatibility Rules

1. **Field mappings must be consistent**: The same field correspondence in both directions
2. **Coercions must be invertible with runtime validation**:
    - ✅ `Int` ↔ `Long` is valid (narrowing validated at runtime)
    - ✅ `Float` ↔ `Double` is valid (narrowing validated at runtime)
    - ✅ All numeric coercions are valid with runtime checks
3. **Optional fields**:
    - ✅ Can add optional fields in one direction (becomes `None` in reverse)
    - ✅ Can remove optional fields in one direction (value is dropped)
4. **Default values**:
    - ❌ Cannot use default arguments (breaks round-trip guarantee)
5. **Collection types**:
    - ✅ Can convert between different collection types
    - ⚠️  Set → List → Set may not preserve original order
    - ⚠️  List → Set → List loses duplicates

### Valid As[A, B] Examples

```scala
// Valid: Same structure, different names
case class PersonV1(name: String, age: Int)
case class PersonV2(fullName: String, yearsOld: Int)

As[PersonV1, PersonV2].into(PersonV1("Alice", 30))
// => Right(PersonV2("Alice", 30))

As[PersonV1, PersonV2].from(PersonV2("Bob", 25))
// => Right(PersonV1("Bob", 25))
```

```scala
// Valid: Case class ↔ Tuple
case class Point(x: Double, y: Double)

As[Point, (Double, Double)].into(Point(1.0, 2.0))
// => Right((1.0, 2.0))

As[Point, (Double, Double)].from((3.0, 4.0))
// => Right(Point(3.0, 4.0))
```

```scala
// Valid: Numeric coercion with runtime validation
case class ConfigV1(timeout: Int)
case class ConfigV2(timeout: Long)

As[ConfigV1, ConfigV2].into(ConfigV1(30))
// => Right(ConfigV2(30L))

As[ConfigV1, ConfigV2].from(ConfigV2(30L))
// => Right(ConfigV1(30))

As[ConfigV1, ConfigV2].from(ConfigV2(3000000000L))
// => Left(SchemaError("Value 3000000000 exceeds Int.MaxValue"))
```

```scala
// Valid: Opaque types (reversible via unwrap)
case class PersonRaw(name: String, age: Int)
case class PersonValidated(name: String, age: Age)

As[PersonRaw, PersonValidated].into(PersonRaw("Alice", 30))
// => Right(PersonValidated("Alice", Age.unsafe(30)))

As[PersonRaw, PersonValidated].from(PersonValidated("Bob", Age.unsafe(25)))
// => Right(PersonRaw("Bob", 25))

As[PersonRaw, PersonValidated].into(PersonRaw("Charlie", -5))
// => Left(SchemaError("Age validation failed: Invalid age: -5"))
```

```scala
// Valid: Collection type conversions
case class DataV1(items: List[Int])
case class DataV2(items: Vector[Int])

As[DataV1, DataV2].into(DataV1(List(1, 2, 3)))
// => Right(DataV2(Vector(1, 2, 3)))

As[DataV1, DataV2].from(DataV2(Vector(4, 5, 6)))
// => Right(DataV1(List(4, 5, 6)))
```

```scala
// Valid: Optional field in one direction
case class UserV1(id: String, name: String)
case class UserV2(id: String, name: String, email: Option[String])

As[UserV1, UserV2].into(UserV1("123", "Alice"))
// => Right(UserV2("123", "Alice", None))

As[UserV1, UserV2].from(UserV2("456", "Bob", Some("bob@example.com")))
// => Right(UserV1("456", "Bob"))
// email is dropped in reverse direction
```

### Non-Ideal As[A, B] Examples (Valid but Lossy)

```scala
// Valid but lossy: List with duplicates → Set → List
case class DataV1(values: List[Int])
case class DataV2(values: Set[Int])

As[DataV1, DataV2].into(DataV1(List(1, 2, 2, 3)))
// => Right(DataV2(Set(1, 2, 3)))

As[DataV1, DataV2].from(DataV2(Set(1, 2, 3)))
// => Right(DataV1(List(1, 2, 3)))
// Original duplicates are lost, but conversion is valid
```

```scala
// Valid but lossy: Set → List → Set (order may change)
case class DataV1(values: Set[Int])
case class DataV2(values: List[Int])

val original = DataV1(Set(3, 1, 2))
val converted = As[DataV1, DataV2].into(original).right.get
// converted.values might be List(1, 2, 3) depending on Set iteration order

val roundTrip = As[DataV1, DataV2].from(converted).right.get
// roundTrip.values == Set(1, 2, 3) - same elements, possibly different internal order
```

### Invalid As[A, B] Examples

```scala
// Invalid: Default values break round-trip guarantee
case class ProductV1(name: String, price: Double)
case class ProductV2(name: String, price: Double, taxable: Boolean = true)

// COMPILE ERROR: Cannot derive As[ProductV1, ProductV2]
// Reason: Default value for 'taxable' cannot be recovered in reverse direction
// (We can't distinguish between explicitly set 'true' and default 'true')
```

---

## Testing Requirements

### Test Matrix Dimensions

1. **Type Combinations** (both `Into` and `As`)
    - Primitive → Primitive (all coercion pairs, including narrowing)
    - Product → Product (case classes)
    - Product → Tuple
    - Tuple → Product
    - Tuple → Tuple
    - Coproduct → Coproduct (sealed traits, enums)
    - Collection[A] → Collection[B] (List, Vector, Set, Map, Option, Either, Array, Seq)
    - Collection type conversions (List ↔ Vector ↔ Set ↔ Array ↔ Seq)
    - Nested conversions
    - Structural types

2. **Disambiguation Scenarios**
    - Unique types (names irrelevant)
    - Matching names (types irrelevant with coercion)
    - Duplicate types with name disambiguation
    - Duplicate types with position disambiguation
    - Ambiguous cases (must fail at compile-time)

3. **Schema Evolution**
    - Field reordering
    - Field renaming (with unique types)
    - Adding optional fields
    - Removing optional fields
    - Type refinement (Int → Long, with narrowing validation)
    - Adding default values (Scala 3)

4. **Validation** (Scala 3 opaque types)
    - Valid values pass through
    - Invalid values produce SchemaError
    - Multiple validation failures accumulate
    - Nested validation in products
    - Validation in coproduct cases
    - Validation in collections
    - Narrowing conversions (Long → Int with overflow check)

5. **Validation** (Scala 2 ZIO Prelude newtypes)
    - Newtype validation success
    - Newtype validation failure
    - Subtype validation with assertions
    - Multiple newtype fields

6. **Collection Type Conversions**
    - List ↔ Vector
    - List ↔ Array
    - List ↔ Set (with duplicate handling)
    - List ↔ Seq
    - Vector ↔ Set
    - Array ↔ Vector
    - All combinations with element type coercion
    - Nested collection type conversions

7. **Runtime Validation** (for `As[A, B]`)
    - Numeric narrowing validation
    - Round-trip with valid narrowing
    - Round-trip failure with overflow
    - Collection conversions with duplicates
    - Optional field round-trips

8. **Error Cases**
    - Ambiguous field mapping (compile error)
    - Ambiguous case mapping (compile error)
    - Default value in `As` (compile error)
    - Runtime validation failures
    - Type mismatch (compile error)
    - Overflow in narrowing conversions

9. **Edge Cases**
    - Empty case classes
    - Single-field case classes
    - Case objects
    - Sealed traits with case objects only
    - Deeply nested structures (5+ levels)
    - Large products (20+ fields)
    - Large coproducts (20+ cases)
    - Recursive types (e.g., `case class Tree(value: Int, children: List[Tree])`)
    - Mutually recursive types

### Test Organization

```
src/test/scala/
  into/
    products/
      CaseClassToCaseClassSpec.scala
      CaseClassToTupleSpec.scala
      TupleToCaseClassSpec.scala
      TupleToTupleSpec.scala
      FieldReorderingSpec.scala
      FieldRenamingSpec.scala
      NestedProductsSpec.scala
    coproducts/
      SealedTraitToSealedTraitSpec.scala
      EnumToEnumSpec.scala (Scala 3 only)
      CaseMatchingSpec.scala
      SignatureMatchingSpec.scala
      AmbiguousCaseSpec.scala
      NestedCoproductsSpec.scala
    primitives/
      NumericWideningSpec.scala
      NumericNarrowingSpec.scala
      CollectionCoercionSpec.scala
      OptionCoercionSpec.scala
      EitherCoercionSpec.scala
      NestedCollectionSpec.scala
    collections/
      ListToVectorSpec.scala
      ListToSetSpec.scala
      VectorToArraySpec.scala
      CollectionTypeWithCoercionSpec.scala
      NestedCollectionTypeSpec.scala
      SetDuplicateHandlingSpec.scala
    structural/
      StructuralTypeTargetSpec.scala (Scala 3 Selectable)
      DynamicTypeTargetSpec.scala (Scala 2 Dynamic)
      StructuralTypeSourceSpec.scala
    validation/
      OpaqueTypeValidationSpec.scala (Scala 3 only)
      ZIONewtypeValidationSpec.scala (Scala 2 only)
      ValidationErrorAccumulationSpec.scala
      NestedValidationSpec.scala
      NarrowingValidationSpec.scala
    evolution/
      AddOptionalFieldSpec.scala
      RemoveOptionalFieldSpec.scala
      TypeRefinementSpec.scala
      AddDefaultFieldSpec.scala (Scala 3 only)
    disambiguation/
      UniqueTypeDisambiguationSpec.scala
      NameDisambiguationSpec.scala
      PositionDisambiguationSpec.scala
      AmbiguousCompileErrorSpec.scala
    edge/
      EmptyProductSpec.scala
      SingleFieldSpec.scala
      CaseObjectSpec.scala
      DeepNestingSpec.scala
      LargeProductSpec.scala
      LargeCoproductSpec.scala
      RecursiveTypeSpec.scala
      MutuallyRecursiveTypeSpec.scala
  
  as/
    reversibility/
      RoundTripProductSpec.scala
      RoundTripCoproductSpec.scala
      RoundTripTupleSpec.scala
      RoundTripCollectionTypeSpec.scala
      OpaqueTypeRoundTripSpec.scala
      NumericNarrowingRoundTripSpec.scala
      OptionalFieldRoundTripSpec.scala
    validation/
      OverflowDetectionSpec.scala
      NarrowingFailureSpec.scala
      CollectionLossyConversionSpec.scala
    compile_errors/
      DefaultValueSpec.scala
    (similar structure to into/ for applicable tests)
```

### Specific Test Cases

#### Disambiguation Tests

```scala
// Test: Unique types make names irrelevant
case class A(x: String, y: Int, z: Boolean)
case class B(a: String, b: Int, c: Boolean)
assert(Into[A, B].into(A("test", 42, true)) == Right(B("test", 42, true)))

// Test: Names disambiguate duplicate types
case class Point(x: Int, y: Int)
case class Coord(y: Int, x: Int)
assert(Into[Point, Coord].into(Point(1, 2)) == Right(Coord(2, 1)))

// Test: Ambiguous mapping fails at compile-time
case class Dim(width: Int, height: Int)
case class Measure(first: Int, second: Int)
// Must not compile: Into[Dim, Measure]
assertDoesNotCompile("Into[Dim, Measure]")
```

#### Numeric Narrowing Validation Tests

```scala
// Test: Valid narrowing conversion
case class V1(value: Long)
case class V2(value: Int)
assert(Into[V1, V2].into(V1(42L)) == Right(V2(42)))

// Test: Invalid narrowing (overflow)
assert(Into[V1, V2].into(V1(3000000000L)).isLeft)

// Test: Narrowing in collections
case class Data1(values: List[Long])
case class Data2(values: List[Int])
assert(Into[Data1, Data2].into(Data1(List(1L, 2L, 3L))) == Right(Data2(List(1, 2, 3))))
assert(Into[Data1, Data2].into(Data1(List(1L, 3000000000L))).isLeft)
```

#### Collection Type Conversion Tests

```scala
// Test: List to Vector
case class A(items: List[Int])
case class B(items: Vector[Int])
assert(Into[A, B].into(A(List(1, 2, 3))) == Right(B(Vector(1, 2, 3))))

// Test: List to Set (removes duplicates)
case class C(items: List[Int])
case class D(items: Set[Int])
assert(Into[C, D].into(C(List(1, 2, 2, 3))) == Right(D(Set(1, 2, 3))))

// Test: Vector to Array
case class E(items: Vector[String])
case class F(items: Array[String])
val result = Into[E, F].into(E(Vector("a", "b")))
assert(result.isRight)
assert(result.right.get.items.sameElements(Array("a", "b")))

// Test: Combined collection and element coercion
case class G(items: List[Int])
case class H(items: Vector[Long])
assert(Into[G, H].into(G(List(1, 2, 3))) == Right(H(Vector(1L, 2L, 3L))))
```

#### Validation Tests (Scala 3)

```scala
// Test: Valid opaque type conversion
case class Raw(age: Int)
case class Validated(age: Age)
assert(Into[Raw, Validated].into(Raw(30)).isRight)

// Test: Invalid opaque type conversion
assert(Into[Raw, Validated].into(Raw(-5)).isLeft)

// Test: Multiple validation failures accumulate
case class RawPerson(age: Int, email: String)
case class ValidPerson(age: Age, email: Email)
val result = Into[RawPerson, ValidPerson].into(RawPerson(-5, "invalid"))
assert(result.isLeft)
// SchemaError contains both validation failures
```

#### Round-Trip Tests (As)

```scala
// Test: Case class round-trip
case class PersonV1(name: String, age: Int)
case class PersonV2(fullName: String, yearsOld: Int)

val v1 = PersonV1("Alice", 30)
val v2 = As[PersonV1, PersonV2].into(v1).right.get
val roundTrip = As[PersonV1, PersonV2].from(v2).right.get

assert(roundTrip == v1)

// Test: Numeric narrowing round-trip (valid)
case class ConfigV1(timeout: Int)
case class ConfigV2(timeout: Long)

val config1 = ConfigV1(30)
val config2 = As[ConfigV1, ConfigV2].into(config1).right.get
val back = As[ConfigV1, ConfigV2].from(config2).right.get

assert(back == config1)

// Test: Numeric narrowing round-trip (overflow failure)
val config2Overflow = ConfigV2(3000000000L)
assert(As[ConfigV1, ConfigV2].from(config2Overflow).isLeft)

// Test: Collection type round-trip
case class Data1(items: List[Int])
case class Data2(items: Vector[Int])

val data1 = Data1(List(1, 2, 3))
val data2 = As[Data1, Data2].into(data1).right.get
val backToData1 = As[Data1, Data2].from(data2).right.get

assert(backToData1 == data1)

// Test: Lossy collection round-trip (Set loses duplicates)
case class WithDuplicates(items: List[Int])
case class NoDuplicates(items: Set[Int])

val original = WithDuplicates(List(1, 2, 2, 3))
val asSet = As[WithDuplicates, NoDuplicates].into(original).right.get
val backToList = As[WithDuplicates, NoDuplicates].from(asSet).right.get

assert(asSet.items == Set(1, 2, 3))
assert(backToList.items.toSet == Set(1, 2, 3)) // Order may differ, duplicates lost
```

#### Edge Case Tests

```scala
// Test: Empty case class
case class Empty()
assert(Into[Empty, Empty].into(Empty()) == Right(Empty()))

// Test: Large product (21 fields)
case class Large21(f1: Int, f2: Int, /* ... */, f21: Int)
case class Large21V2(f1: Long, f2: Long, /* ... */, f21: Long)
// Must compile and work correctly

// Test: Recursive type
case class Tree(value: Int, children: List[Tree])
case class TreeV2(value: Long, children: List[TreeV2])
val tree = Tree(1, List(Tree(2, Nil), Tree(3, Nil)))
val treeV2 = Into[Tree, TreeV2].into(tree).right.get
assert(treeV2.value == 1L)
assert(treeV2.children.head.value == 2L)

// Test: Mutually recursive types
case class Node(id: Int, edges: List[Edge])
case class Edge(from: Int, to: Node)
case class NodeV2(id: Long, edges: List[EdgeV2])
case class EdgeV2(from: Long, to: NodeV2)
// Must compile and handle mutual recursion
```

---

## Implementation Signatures

### Scala 3.5

```scala
package zio.blocks.schema

import scala.quoted.*

// One-way conversion
trait Into[-A, +B] {
  def into(input: A): Either[SchemaError, B]
}

object Into {
  inline given [A, B]: Into[A, B] = ${intoMacro[A, B]}
  
  private def intoMacro[A: Type, B: Type](using Quotes): Expr[Into[A, B]] = {
    import quotes.reflect.*
    // Implementation:
    // 1. Analyze types A and B
    // 2. Build field mapping using disambiguation algorithm
    // 3. Detect opaque types and generate validation calls
    // 4. Generate narrowing validation for numeric coercions
    // 5. Handle collection type conversions
    // 6. Generate conversion code
    // 7. Handle nested conversions recursively
    ???
  }
}

// Bidirectional conversion
trait As[A, B] {
  def into(input: A): Either[SchemaError, B]
  def from(input: B): Either[SchemaError, A]
}

object As {
  inline given [A, B]: As[A, B] = ${asMacro[A, B]}
  
  private def asMacro[A: Type, B: Type](using Quotes): Expr[As[A, B]] = {
    import quotes.reflect.*
    // Implementation:
    // 1. Verify bidirectional compatibility
    // 2. Check for default values (compile error if found)
    // 3. Build bidirectional field mapping
    // 4. Generate both conversion directions with validation
    // 5. Ensure opaque type wrapping/unwrapping is symmetric
    // 6. Handle numeric narrowing with runtime validation
    // 7. Handle collection type conversions bidirectionally
    ???
  }
}
```

### Scala 2.13

```scala
package com.yourorg.schema

import scala.reflect.macros.blackbox.Context
import scala.language.experimental.macros

case class SchemaError(msg: String) {
  // SchemaError is composable - can combine multiple errors
}

// One-way conversion
trait Into[-A, +B] {
  def into(input: A): Either[SchemaError, B]
}

object Into {
  implicit def materializeInto[A, B]: Into[A, B] = macro materializeIntoImpl[A, B]
  
  def materializeIntoImpl[A: c.WeakTypeTag, B: c.WeakTypeTag](c: Context): c.Tree = {
    import c.universe._
    // Implementation:
    // 1. Analyze types A and B using reflection
    // 2. Build field mapping using disambiguation algorithm
    // 3. Detect ZIO Prelude newtypes via AST pattern matching
    // 4. Generate narrowing validation for numeric coercions
    // 5. Handle collection type conversions
    // 6. Generate conversion code using quasiquotes
    // 7. Handle nested conversions recursively
    ???
  }
}

// Bidirectional conversion
trait As[A, B] {
  def into(input: A): Either[SchemaError, B]
  def from(input: B): Either[SchemaError, A]
}

object As {
  implicit def materializeAs[A, B]: As[A, B] = macro materializeAsImpl[A, B]
  
  def materializeAsImpl[A: c.WeakTypeTag, B: c.WeakTypeTag](c: Context): c.Tree = {
    import c.universe._
    // Implementation:
    // 1. Verify bidirectional compatibility
    // 2. Check for default values (compile error if found)
    // 3. Build bidirectional field mapping
    // 4. Generate both conversion directions with validation
    // 5. Ensure newtype wrapping/unwrapping is symmetric
    // 6. Handle numeric narrowing with runtime validation
    // 7. Handle collection type conversions bidirectionally
    ???
  }
}
```

---

## Implementation Notes

### Error Messages

Provide helpful compile-time errors:

```scala
// Good error message example:
"""
Cannot derive Into[PersonV1, PersonV2]: Ambiguous field mapping

  PersonV1(width: Int, height: Int)
  PersonV2(first: Int, second: Int)

Cannot determine unique mapping between fields of type Int.
Consider:
  - Using matching field names (width/height)
  - Making field types unique
  - Providing an explicit Into instance
"""
```

### Cross-Version Compatibility

- Share test cases between Scala 2 and Scala 3 where possible

---

## Deliverables

1. ✅ `Into[A, B]` trait and macro for Scala 2.13
2. ✅ `Into[A, B]` trait and macro for Scala 3.5
3. ✅ `As[A, B]` trait and macro for Scala 2.13
4. ✅ `As[A, B]` trait and macro for Scala 3.5
5. ✅ Comprehensive test suite
6. ✅ Documentation with examples
