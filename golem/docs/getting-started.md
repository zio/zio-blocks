# Getting started (Scala.js) — create a new project from scratch

This guide shows how to build a **new Scala.js agent project** that can be deployed with `golem-cli`.

You’ll create:

- A Scala.js project producing a single `scala.js` bundle
- A small `golem.yaml` app that tells `golem-cli` how to build + wrap your bundle into a component
- Automatic agent registration (generated by `GolemPlugin`) so Golem can discover your `@agentImplementation`s

If you’re working inside this monorepo, the canonical, runnable version of this guide is checked in at
`golem/gettingStarted/` — you can run it end-to-end with:

```bash
bash golem/gettingStarted/run.sh
```

## Prerequisites

- **`golem-cli`** on your `PATH`
- **Java + sbt**
- **A reachable Golem router/executor**
  - Local: run `golem server run` in another terminal
  - Cloud: configure a cloud profile (e.g. `golem-cli --cloud profile list`)

## 1) Create the Scala.js project

First, create a new project directory and enter it:

```bash
mkdir scala-demo
cd scala-demo
```

Create these directories:

```bash
mkdir -p scala/project scala/src/main/scala/demo
mkdir -p common-scala-js components-js/scala-demo/src wasm
```

All commands below assume your working directory is the **project root** (the directory that contains `golem.yaml`, `common-scala-js/`, `components-js/`, and `wasm/`).

Create `scala/project/plugins.sbt`:

```scala
addSbtPlugin("dev.zio" % "zio-golem-sbt" % "<SDK_VERSION>")
addSbtPlugin("org.scala-js" % "sbt-scalajs" % "1.20.2")
```

### Enable `GolemPlugin` (automatic registration)

Scala.js agents must register their `@agentImplementation` classes so Golem can discover them at runtime.

**You should not write any registration code by hand.** Instead, enable the `golem.sbt.GolemPlugin` SBT plugin, which
generates the required exported entrypoint automatically.

## 2) Add dependencies + enable plugins

Create `scala/build.sbt`:

```scala
import org.scalajs.linker.interface.ModuleKind

ThisBuild / scalaVersion := "3.3.7"

lazy val root = project
  .in(file("."))
  .enablePlugins(org.scalajs.sbtplugin.ScalaJSPlugin, golem.sbt.GolemPlugin)
  .settings(
    scalaJSUseMainModuleInitializer := false,
    Compile / scalaJSLinkerConfig ~= (_.withModuleKind(ModuleKind.ESModule)),
    libraryDependencies ++= Seq(
      "dev.zio" %%% "zio-golem-core"  % "<SDK_VERSION>",
      "dev.zio" %%% "zio-golem-model" % "<SDK_VERSION>",
      "dev.zio" %% "zio-golem-macros" % "<SDK_VERSION>"
    ),
    golemBasePackage := Some("demo")
  )
```

Notes:

- **`<SDK_VERSION>`** should be a released version from Maven Central.
- If you’re hacking **inside this monorepo**, you can use `0.0.0-SNAPSHOT` after running:

```bash
sbt -batch -no-colors -Dsbt.supershell=false golemPublishLocal
```

## 3) Write a minimal agent

Create `scala/src/main/scala/demo/CounterAgent.scala`:

```scala
package demo

import golem.runtime.annotations.{agentDefinition, description, prompt}
import golem.{AgentCompanion, BaseAgent}

import scala.concurrent.Future

@agentDefinition(typeName = "counter-agent")
trait CounterAgent extends BaseAgent[String] {

  @prompt("Increase the count by one")
  @description("Increases the count by one and returns the new value")
  def increment(): Future[Int]
}

object CounterAgent extends AgentCompanion[CounterAgent]
```

### Remote invocation variants (await/trigger/schedule)

All agent methods support three invocation styles. Use `getRemote(...)` plus
`RemoteAgentOps` to access them:

```scala
import golem.{Datetime, RemoteAgentOps}
import golem.RemoteAgentOps.*

val remote = CounterAgent.getRemote("shard-id")

// Await (always invoke-and-await)
remote.flatMap(_.rpc.call_increment())

// Fire-and-forget trigger
remote.flatMap(_.rpc.trigger_increment())

// Schedule (run 5 seconds later)
remote.flatMap(_.rpc.schedule_increment(Datetime.afterSeconds(5)))
```

Notes:

- Works in Scala 2.13 and Scala 3.
- `trigger_*` / `schedule_*` always return `Future[Unit]` by design.
- `remote.api.increment()` still performs the “normal” call style, while
  `remote.rpc.call_increment()` always invokes the await path.

### Custom data types (Schemas)

If you use custom Scala types as **constructor inputs** (`BaseAgent[MyInput]`) or **method parameters/return values**,
the SDK must be able to derive a `golem.data.GolemSchema[T]` for them.

You normally **do not** define `GolemSchema` directly — instead, derive/provide a `zio.blocks.schema.Schema[T]`,
and `GolemSchema` will be derived automatically from it.

For example (Scala 3):

```scala
import zio.blocks.schema.Schema

final case class State(value: Int) derives Schema
```

Create `scala/src/main/scala/demo/CounterAgentImpl.scala`:

```scala
package demo

import golem.runtime.annotations.agentImplementation

import scala.annotation.unused
import scala.concurrent.Future

@agentImplementation()
final class CounterAgentImpl(@unused private val name: String) extends CounterAgent {
  private var count: Int = 0

  override def increment(): Future[Int] =
    Future.successful {
      count += 1
      count
    }
}
```

## 4) Create a `golem.yaml` app with a `scala.js` template

Create `golem.yaml`:

```yaml
app: scala-demo

environments:
  local:
    server: local
    componentPresets: debug

includes:
- common-*/golem.yaml
- components-*/*/golem.yaml
```

Create `common-scala-js/golem.yaml`:

```yaml
componentTemplates:
  scala.js:
    build:
    - command: bash ../../build-scalajs.sh {{ component_name }}
      sources:
      - src
      targets:
      - src/scala.js
    - injectToPrebuiltQuickjs: ../../wasm/agent_guest.wasm
      module: src/scala.js
      moduleWasm: ../../golem-temp/agents/{{ component_name | to_snake_case }}.module.wasm
      into: ../../golem-temp/agents/{{ component_name | to_snake_case }}.dynamic.wasm
    - generateAgentWrapper: ../../golem-temp/agents/{{ component_name | to_snake_case }}.wrapper.wasm
      basedOnCompiledWasm: ../../golem-temp/agents/{{ component_name | to_snake_case }}.dynamic.wasm
    - composeAgentWrapper: ../../golem-temp/agents/{{ component_name | to_snake_case }}.wrapper.wasm
      withAgent: ../../golem-temp/agents/{{ component_name | to_snake_case }}.dynamic.wasm
      to: ../../golem-temp/agents/{{ component_name | to_snake_case }}.static.wasm
    sourceWit: ../../wasm/agent_guest.wasm
    generatedWit: ../../golem-temp/agents/{{ component_name | to_snake_case }}/wit-generated
    componentWasm: ../../golem-temp/agents/{{ component_name | to_snake_case }}.static.wasm
    linkedWasm: ../../golem-temp/agents/{{ component_name | to_snake_case }}.wasm
```

Create `components-js/scala-demo/golem.yaml`:

```yaml
components:
  scala:demo:
    # Use the shared Scala.js component template defined in common-scala-js/golem.yaml
    templates: scala.js
```

Create `build-scalajs.sh`:

```bash
#!/usr/bin/env bash
set -euo pipefail

component="${1:-}"
if [[ -z "$component" ]]; then
  echo "usage: $0 <component_name>" >&2
  exit 2
fi

component_dir="$PWD"

app_root="$(cd "$(dirname "$0")" && pwd)"
scala_dir="$app_root/scala"

build_log="$(mktemp)"
trap 'rm -f "$build_log"' EXIT
if ! ( cd "$scala_dir" && sbt -batch -no-colors -Dsbt.supershell=false "compile" "fastLinkJS" ) >"$build_log" 2>&1; then
  cat "$build_log" >&2
  echo "[scala.js] sbt failed; see output above." >&2
  exit 1
fi

bundle="$(
  python3 - <<'PY' "$scala_dir"
import sys
from pathlib import Path

scala_dir = Path(sys.argv[1])
target = scala_dir / "target"
if not target.exists():
  print("")
  raise SystemExit(0)

def newest(pattern: str) -> str:
  candidates = list(target.rglob(pattern))
  if not candidates:
    return ""
  candidates.sort(key=lambda p: p.stat().st_mtime, reverse=True)
  return str(candidates[0])

print(newest("*/**/*fastopt*/main.js") or "")
PY
)"
if [[ -z "$bundle" ]]; then
  bundle="$(
    python3 - <<'PY' "$scala_dir"
import sys
from pathlib import Path

scala_dir = Path(sys.argv[1])
target = scala_dir / "target"
if not target.exists():
  print("")
  raise SystemExit(0)

def newest(pattern: str) -> str:
  candidates = list(target.rglob(pattern))
  if not candidates:
    return ""
  candidates.sort(key=lambda p: p.stat().st_mtime, reverse=True)
  return str(candidates[0])

print(newest("*/**/*fullopt*/main.js") or "")
PY
  )"
fi
if [[ -z "$bundle" ]]; then
  echo "[scala.js] Could not locate Scala.js bundle under $scala_dir/target" >&2
  exit 1
fi

mkdir -p "$component_dir/src"
cp "$bundle" "$component_dir/src/scala.js"
```

Then:

```bash
chmod +x build-scalajs.sh
```

## 5) Provide the base guest runtime WASM (`agent_guest.wasm`)

The `zio-golem-sbt` plugin ships a compatible `agent_guest.wasm` embedded as a resource and will ensure it exists at
`wasm/agent_guest.wasm` automatically during normal builds (compile/link), if the file is missing.

If your project layout is different, set `golemAgentGuestWasmFile` in `scala/build.sbt`
to point at the desired output file.

## 6) Deploy + invoke

If you see authentication / login errors (especially when switching between local and remote setups), it can help to reset the local server state:

```bash
golem-cli server run --clean --local
```

Build the Scala.js bundle once (optional, but useful to validate your build before running `golem-cli`):

```bash
cd scala
sbt -batch -no-colors -Dsbt.supershell=false "compile" "fastLinkJS"
cd ..
```

Deploy from the project root:

```bash
env -u ARGV0 golem-cli --local --yes --app-manifest-path "$PWD/golem.yaml" deploy
```

Create `repl-counter.rib` in the project root.

Use a fresh agent id each time you run the script; the default durability mode is **Durable**, so reusing the same id will
keep incrementing the existing counter.

```bash
agent_id="demo-$(date +%s)"
cat > repl-counter.rib <<EOF
let c = counter-agent("$agent_id");
let a = c.increment();
let b = c.increment();
{ a: a, b: b }
EOF
```

Then run it non-interactively (recommended for automation):

```bash
env -u ARGV0 golem-cli --local --yes --app-manifest-path "$PWD/golem.yaml" \
  repl scala:demo --script-file repl-counter.rib --disable-stream < /dev/null
```
