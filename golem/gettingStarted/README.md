# Getting started (Scala.js) -- create a new project from scratch

This guide shows how to build a **new Scala.js agent project** that can be deployed with `golem-cli`.

You'll create:

- A Scala.js project producing a single `scala.js` bundle
- A `golem.yaml` app manifest that tells `golem-cli` how to build + wrap your bundle into a component
- Automatic agent registration (generated by `GolemPlugin`) so Golem can discover your `@agentImplementation`s

## Running from this monorepo

From the repository root:

```bash
sbt -batch -no-colors -Dsbt.supershell=false golemPublishLocal
```

Then you can run this example end-to-end:

```bash
bash golem/gettingStarted/run.sh
```

If you see authentication / login errors (especially when switching between local and remote setups),
reset the local server state:

```bash
golem-cli server run --clean --local
```

## Prerequisites

- **`golem-cli`** on your `PATH`
- **Java + sbt**
- **A reachable Golem router/executor**
  - Local: run `golem server run` in another terminal
  - Cloud: configure a cloud profile (e.g. `golem-cli --cloud profile list`)

## 1) Create the Scala.js project

Create a new project directory and enter it:

```bash
mkdir scala-demo
cd scala-demo
```

Create the directory structure:

```bash
mkdir -p project src/main/scala/demo
```

Create `project/plugins.sbt`:

```scala
addSbtPlugin("dev.zio" % "zio-golem-sbt" % "<SDK_VERSION>")
addSbtPlugin("org.scala-js" % "sbt-scalajs" % "1.20.2")
```

### Enable `GolemPlugin` (automatic registration)

Scala.js agents must register their `@agentImplementation` classes so Golem can discover them at runtime.

**You should not write any registration code by hand.** Instead, enable the `golem.sbt.GolemPlugin` SBT plugin, which
generates the required exported entrypoint automatically.

## 2) Add dependencies + enable plugins

Create `build.sbt`:

```scala
import org.scalajs.linker.interface.ModuleKind

ThisBuild / scalaVersion := "3.3.7"

lazy val root = project
  .in(file("."))
  .enablePlugins(org.scalajs.sbtplugin.ScalaJSPlugin, golem.sbt.GolemPlugin)
  .settings(
    scalaJSUseMainModuleInitializer := false,
    Compile / scalaJSLinkerConfig ~= (_.withModuleKind(ModuleKind.ESModule)),
    libraryDependencies ++= Seq(
      "dev.zio" %%% "zio-golem-core"  % "<SDK_VERSION>",
      "dev.zio" %%% "zio-golem-model" % "<SDK_VERSION>",
      "dev.zio" %% "zio-golem-macros" % "<SDK_VERSION>"
    ),
    golemBasePackage := Some("demo")
  )
```

Notes:

- **`<SDK_VERSION>`** should be a released version from Maven Central.
- If you're hacking **inside this monorepo**, you can use `0.0.0-SNAPSHOT` after running:

```bash
sbt -batch -no-colors -Dsbt.supershell=false golemPublishLocal
```

## 3) Write a minimal agent

Create `src/main/scala/demo/CounterAgent.scala`:

```scala
package demo

import golem.runtime.annotations.{agentDefinition, description, prompt}
import golem.{AgentCompanion, BaseAgent}

import scala.concurrent.Future

@agentDefinition(typeName = "counter-agent")
trait CounterAgent extends BaseAgent[String] {

  @prompt("Increase the count by one")
  @description("Increases the count by one and returns the new value")
  def increment(): Future[Int]
}

object CounterAgent extends AgentCompanion[CounterAgent, String]
```

For RPC invocation variants and custom schema derivation, see `golem/README.md`.

Create `src/main/scala/demo/CounterAgentImpl.scala`:

```scala
package demo

import golem.runtime.annotations.agentImplementation

import scala.annotation.unused
import scala.concurrent.Future

@agentImplementation()
final class CounterAgentImpl(@unused private val name: String) extends CounterAgent {
  private var count: Int = 0

  override def increment(): Future[Int] =
    Future.successful {
      count += 1
      count
    }
}
```

## 4) Create a `golem.yaml` app manifest

Create `golem.yaml` in the project root. The `componentTemplates` section defines how `golem-cli` builds your Scala.js component. The sbt `golemBuildComponent` task compiles Scala.js and writes the bundle; the sbt `golemPrepare` task (triggered automatically by compile) writes `.generated/agent_guest.wasm`:

```yaml
app: scala-demo

environments:
  local:
    server: local

components:
  scala:demo:
    templates: scala.js

componentTemplates:
  scala.js:
    build:
    - command: sbt -batch -no-colors -Dsbt.supershell=false "golemBuildComponent {{ component_name }} .golem/scala.js"
      sources:
      - src
      targets:
      - .golem/scala.js
    - injectToPrebuiltQuickjs: .generated/agent_guest.wasm
      module: .golem/scala.js
      moduleWasm: .golem/agents/{{ component_name | to_snake_case }}.module.wasm
      into: .golem/agents/{{ component_name | to_snake_case }}.dynamic.wasm
    - generateAgentWrapper: .golem/agents/{{ component_name | to_snake_case }}.wrapper.wasm
      basedOnCompiledWasm: .golem/agents/{{ component_name | to_snake_case }}.dynamic.wasm
    - composeAgentWrapper: .golem/agents/{{ component_name | to_snake_case }}.wrapper.wasm
      withAgent: .golem/agents/{{ component_name | to_snake_case }}.dynamic.wasm
      to: .golem/agents/{{ component_name | to_snake_case }}.static.wasm
    sourceWit: .generated/agent_guest.wasm
    generatedWit: .golem/agents/{{ component_name | to_snake_case }}/wit-generated
    componentWasm: .golem/agents/{{ component_name | to_snake_case }}.static.wasm
    linkedWasm: .golem/agents/{{ component_name | to_snake_case }}.wasm
```

## 5) Deploy + invoke

First, ensure `agent_guest.wasm` exists (golem-cli needs it before running build steps):

```bash
sbt golemPrepare
```

Then build, deploy, and interact:

```bash
golem-cli build --yes
golem-cli deploy --yes
golem-cli repl scala:demo --script-file repl-counter.rib
```

If you see authentication / login errors, reset the local server state:

```bash
golem-cli server run --clean --local
```
