package example.minimal

import golem.Transactions
import golem.Transactions._
import golem.runtime.annotations.agentImplementation

import scala.annotation.unused
import scala.concurrent.Future

@agentImplementation()
final class TransactionsDemoImpl(@unused private val name: String) extends TransactionsDemo {

  private var trace: List[String] = Nil

  private def appendTrace(msg: String): Unit =
    trace = trace :+ msg

  private def resetAndGetTrace(): String = {
    val result = trace.mkString("\n")
    trace = Nil
    result
  }

  override def infallibleDemo(): Future[String] = Future.successful {
    val sb = new StringBuilder
    sb.append("=== Infallible Transaction Demo ===\n")

    val op1 = Transactions.operation[Int, Int, String](
      run = i => { appendTrace(s"op1.run($i)"); Right(i + 10) }
    )(
      compensate = (input, output) => { appendTrace(s"op1.compensate($input,$output)"); Right(()) }
    )
    val op2 = Transactions.operation[Int, Int, String](
      run = i => { appendTrace(s"op2.run($i)"); Right(i * 2) }
    )(
      compensate = (input, output) => { appendTrace(s"op2.compensate($input,$output)"); Right(()) }
    )

    val result = Transactions.infallibleTransaction { tx =>
      val r1 = tx.execute(op1, 5)
      appendTrace(s"op1 result=$r1")
      val r2 = tx.execute(op2, r1)
      appendTrace(s"op2 result=$r2")
      r2
    }

    sb.append(s"transaction result=$result\n")
    sb.append("trace:\n")
    sb.append(resetAndGetTrace())
    sb.append("\n")
    sb.result()
  }

  override def fallibleSuccessDemo(): Future[String] = Future.successful {
    val sb = new StringBuilder
    sb.append("=== Fallible Transaction (Success) Demo ===\n")

    val op1 = Operation[Int, Int, String](
      run = i => { appendTrace(s"op1.run($i)"); Right(i + 100) },
      compensateFn = (input, output) => { appendTrace(s"op1.compensate($input,$output)"); Right(()) }
    )
    val op2 = Operation[Int, Int, String](
      run = i => { appendTrace(s"op2.run($i)"); Right(i - 50) },
      compensateFn = (input, output) => { appendTrace(s"op2.compensate($input,$output)"); Right(()) }
    )

    val result = Transactions.fallibleTransaction[Int, String] { tx =>
      val r1 = tx.execute(op1, 1)
      appendTrace(s"op1 result=$r1")
      r1 match {
        case Left(err) => Left(err)
        case Right(v1) =>
          val r2 = tx.execute(op2, v1)
          appendTrace(s"op2 result=$r2")
          r2
      }
    }

    sb.append(s"transaction result=$result\n")
    sb.append("trace:\n")
    sb.append(resetAndGetTrace())
    sb.append("\n")
    sb.result()
  }

  override def fallibleFailureDemo(): Future[String] = Future.successful {
    val sb = new StringBuilder
    sb.append("=== Fallible Transaction (Failure + Rollback) Demo ===\n")

    val op1 = Operation[Int, Int, String](
      run = i => { appendTrace(s"op1.run($i)"); Right(i + 1) },
      compensateFn = (input, output) => { appendTrace(s"op1.compensate($input,$output)"); Right(()) }
    )
    val op2 = Operation[Int, Int, String](
      run = i => { appendTrace(s"op2.run($i)"); Right(i + 2) },
      compensateFn = (input, output) => { appendTrace(s"op2.compensate($input,$output)"); Right(()) }
    )
    val failOp = Operation[Int, Int, String](
      run = i => { appendTrace(s"failOp.run($i) -> LEFT"); Left("intentional-failure") },
      compensateFn = (input, output) => { appendTrace(s"failOp.compensate($input,$output)"); Right(()) }
    )

    val result = Transactions.fallibleTransaction[Int, String] { tx =>
      val r1 = tx.execute(op1, 10)
      appendTrace(s"op1 result=$r1")
      r1 match {
        case Left(err) => Left(err)
        case Right(v1) =>
          val r2 = tx.execute(op2, v1)
          appendTrace(s"op2 result=$r2")
          r2 match {
            case Left(err) => Left(err)
            case Right(v2) =>
              val r3 = tx.execute(failOp, v2)
              appendTrace(s"failOp result=$r3")
              r3
          }
      }
    }

    val resultStr = result match {
      case Right(v)                                                            => s"Right($v)"
      case Left(TransactionFailure.FailedAndRolledBackCompletely(err))         => s"FailedAndRolledBackCompletely($err)"
      case Left(TransactionFailure.FailedAndRolledBackPartially(err, compErr)) =>
        s"FailedAndRolledBackPartially($err, $compErr)"
    }

    sb.append(s"transaction result=$resultStr\n")
    sb.append("trace:\n")
    sb.append(resetAndGetTrace())
    sb.append("\n")
    sb.result()
  }
}
