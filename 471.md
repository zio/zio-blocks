```scala
// ============================================================================
// Owner: Where a type is defined
// ============================================================================

final case class Owner(segments: List[Owner.Segment]) {
  def asString: String = segments.map(_.name).mkString(".")
}

object Owner {
  sealed trait Segment { def name: String }

  final case class Package(name: String) extends Segment
  final case class Term(name: String)    extends Segment
  final case class Type(name: String)    extends Segment

  val Root: Owner = Owner(Nil)
}

// ============================================================================
// TypeParam: Type parameter specification
// ============================================================================

final case class TypeParam(
  name: String,
  index: Int
  // Can extend with: variance, bounds, kind
)

// ============================================================================
// TypeId: Identity of a type or type constructor (phantom-typed by A)
// ============================================================================

sealed trait TypeId[A <: AnyKind] {
  def name: String
  def owner: Owner
  def typeParams: List[TypeParam]

  final def arity: Int = typeParams.size

  final def fullName: String =
    if (owner.segments.isEmpty) name
    else owner.asString + "." + name
}

object TypeId {
  private final case class NominalImpl(
    name: String,
    owner: Owner,
    typeParams: List[TypeParam]
  ) extends TypeId[Nothing]

  private final case class AliasImpl(
    name: String,
    owner: Owner,
    typeParams: List[TypeParam],
    aliased: TypeRepr
  ) extends TypeId[Nothing]

  private final case class OpaqueImpl(
    name: String,
    owner: Owner,
    typeParams: List[TypeParam],
    representation: TypeRepr
  ) extends TypeId[Nothing]

  /** Macro-derived TypeId for any type or type constructor */
  def derive[A <: AnyKind]: TypeId[A] =
    macro TypeIdMacros.deriveMacro[A]

  /** Manual construction: nominal type */
  def nominal[A <: AnyKind](
    name: String,
    owner: Owner,
    typeParams: List[TypeParam]
  ): TypeId[A] =
    NominalImpl(name, owner, typeParams).asInstanceOf[TypeId[A]]

  /** Manual construction: type alias */
  def alias[A <: AnyKind](
    name: String,
    owner: Owner,
    typeParams: List[TypeParam],
    aliased: TypeRepr
  ): TypeId[A] =
    AliasImpl(name, owner, typeParams, aliased).asInstanceOf[TypeId[A]]

  /** Manual construction: opaque type */
  def opaque[A <: AnyKind](
    name: String,
    owner: Owner,
    typeParams: List[TypeParam],
    representation: TypeRepr
  ): TypeId[A] =
    OpaqueImpl(name, owner, typeParams, representation).asInstanceOf[TypeId[A]]

  /** Pattern matching support */
  object Nominal {
    def unapply(id: TypeId[_]): Option[(String, Owner, List[TypeParam])] = id match {
      case impl: NominalImpl => Some((impl.name, impl.owner, impl.typeParams))
      case _                 => None
    }
  }

  object Alias {
    def unapply(id: TypeId[_]): Option[(String, Owner, List[TypeParam], TypeRepr)] = id match {
      case impl: AliasImpl => Some((impl.name, impl.owner, impl.typeParams, impl.aliased))
      case _               => None
    }
  }

  object Opaque {
    def unapply(id: TypeId[_]): Option[(String, Owner, List[TypeParam], TypeRepr)] = id match {
      case impl: OpaqueImpl => Some((impl.name, impl.owner, impl.typeParams, impl.representation))
      case _                => None
    }
  }
}

// ============================================================================
// TypeRepr: Type expressions
// ============================================================================

sealed trait TypeRepr

object TypeRepr {
  /** Reference to a named type constructor (unapplied).
    * - If id.arity == 0, this is already a proper type
    * - If id.arity > 0, this is a type constructor
    */
  final case class Ref(id: TypeId[_ <: AnyKind]) extends TypeRepr

  /** Reference to a type parameter (can itself be a constructor) */
  final case class ParamRef(param: TypeParam) extends TypeRepr

  /** Application of a type constructor to arguments.
    * Examples:
    *   List[Int]   → Applied(Ref(listId), List(Ref(intId)))
    *   F[A]        → Applied(ParamRef(F), List(ParamRef(A)))
    */
  final case class Applied(
    tycon: TypeRepr,
    args: List[TypeRepr]
  ) extends TypeRepr

  /** Structural/refinement type: { def foo: Int; type T; ... } */
  final case class Structural(
    parents: List[TypeRepr],
    members: List[Member]
  ) extends TypeRepr

  /** Intersection type: A & B */
  final case class Intersection(left: TypeRepr, right: TypeRepr) extends TypeRepr

  /** Union type: A | B */
  final case class Union(left: TypeRepr, right: TypeRepr) extends TypeRepr

  /** Tuple type: (A, B, C) */
  final case class Tuple(elems: List[TypeRepr]) extends TypeRepr

  /** Function type: (A, B) => C */
  final case class Function(params: List[TypeRepr], result: TypeRepr) extends TypeRepr

  /** Singleton type: x.type */
  final case class Singleton(path: TermPath) extends TypeRepr

  /** Constant/literal type: 42, "foo", true */
  final case class Constant(value: Any) extends TypeRepr

  /** Top type */
  case object AnyType extends TypeRepr

  /** Bottom type */
  case object NothingType extends TypeRepr
}

// ============================================================================
// Member: Structural type members
// ============================================================================

sealed trait Member

object Member {
  final case class Val(
    name: String,
    tpe: TypeRepr,
    isVar: Boolean = false
  ) extends Member

  final case class Def(
    name: String,
    paramLists: List[List[Param]],
    result: TypeRepr
  ) extends Member

  final case class TypeMember(
    name: String,
    typeParams: List[TypeParam],
    lowerBound: Option[TypeRepr],
    upperBound: Option[TypeRepr]
  ) extends Member
}

final case class Param(name: String, tpe: TypeRepr)

// ============================================================================
// TermPath: For singleton types
// ============================================================================

final case class TermPath(segments: List[TermPath.Segment])

object TermPath {
  sealed trait Segment { def name: String }

  final case class Package(name: String) extends Segment
  final case class Term(name: String)    extends Segment
}

// ============================================================================
// Examples
// ============================================================================

object Examples {
  import TypeId.{nominal, alias, opaque}
  import TypeRepr._
  import Member._

  private val pkgScala          = Owner(List(Owner.Package("scala")))
  private val pkgScalaCollection =
    Owner(List(Owner.Package("scala"), Owner.Package("collection"), Owner.Package("immutable")))
  private val pkgJavaLang       = Owner(List(Owner.Package("java"), Owner.Package("lang")))
  private val pkgMyApp          = Owner(List(Owner.Package("myapp")))

  // ===== Basic nominal types =====

  val intId: TypeId[Int]       = nominal[Int]("Int", pkgScala, Nil)
  val stringId: TypeId[String] = nominal[String]("String", pkgJavaLang, Nil)
  val booleanId: TypeId[Boolean] = nominal[Boolean]("Boolean", pkgScala, Nil)

  val intType: TypeRepr     = Ref(intId)
  val stringType: TypeRepr  = Ref(stringId)
  val booleanType: TypeRepr = Ref(booleanId)

  // ===== Type constructors =====

  val A = TypeParam("A", 0)
  val B = TypeParam("B", 1)
  val K = TypeParam("K", 0)
  val V = TypeParam("V", 1)

  val listId: TypeId[List]   = nominal[List]("List", pkgScalaCollection, List(A))
  val optionId: TypeId[Option] = nominal[Option]("Option", pkgScala, List(A))
  val mapId: TypeId[Map]     = nominal[Map]("Map", pkgScalaCollection, List(K, V))
  val eitherId: TypeId[Either] = nominal[Either]("Either", pkgScala, List(A, B))

  // Type constructors (unapplied)
  val listConstructor: TypeRepr   = Ref(listId)
  val optionConstructor: TypeRepr = Ref(optionId)

  // Applied types
  val listIntType: TypeRepr       = Applied(Ref(listId), List(intType))
  val optionStringType: TypeRepr  = Applied(Ref(optionId), List(stringType))
  val mapStringIntType: TypeRepr  = Applied(Ref(mapId), List(stringType, intType))

  // ===== Type aliases =====

  // type Age = Int
  val ageId: TypeId[Int] = alias[Int](
    name       = "Age",
    owner      = pkgMyApp,
    typeParams = Nil,
    aliased    = intType
  )
  val ageType: TypeRepr = Ref(ageId)

  // type MyList[A] = List[A]
  val myListId: TypeId[List] = alias[List](
    name       = "MyList",
    owner      = pkgMyApp,
    typeParams = List(A),
    aliased    = Applied(Ref(listId), List(ParamRef(A)))
  )

  // type StringMap[V] = Map[String, V]
  val stringMapId: TypeId[Map[String, *]] = alias[Map[String, *]](
    name       = "StringMap",
    owner      = pkgMyApp,
    typeParams = List(V),
    aliased    = Applied(Ref(mapId), List(stringType, ParamRef(V)))
  )

  // type Id[A] = A
  val idId: TypeId[AnyKind] = alias[AnyKind](
    name       = "Id",
    owner      = pkgMyApp,
    typeParams = List(A),
    aliased    = ParamRef(A)
  )

  // ===== Opaque types =====

  // opaque type Email = String
  val emailId: TypeId[String] = opaque[String](
    name           = "Email",
    owner          = pkgMyApp,
    typeParams     = Nil,
    representation = stringType
  )
  val emailType: TypeRepr = Ref(emailId)

  // opaque type SafeList[A] = List[A]
  val safeListId: TypeId[List] = opaque[List](
    name           = "SafeList",
    owner          = pkgMyApp,
    typeParams     = List(A),
    representation = Applied(Ref(listId), List(ParamRef(A)))
  )

  // ===== Structural types =====

  // { def size: Int; val isEmpty: Boolean }
  val sizedType: TypeRepr = Structural(
    parents = Nil,
    members = List(
      Def("size", Nil, intType),
      Val("isEmpty", booleanType, isVar = false)
    )
  )

  // type Record[A] = { def value: A }
  val recordId: TypeId[AnyKind] = alias[AnyKind](
    name       = "Record",
    owner      = pkgMyApp,
    typeParams = List(A),
    aliased    = Structural(
      parents = Nil,
      members = List(
        Def("value", Nil, ParamRef(A))
      )
    )
  )

  // { type T; def get: T }
  val T = TypeParam("T", 0)
  val genericGetterType: TypeRepr = Structural(
    parents = Nil,
    members = List(
      TypeMember("T", Nil, None, None),
      // Note: ParamRef(T) here is a shorthand for "the type member T";
      // if you want precise scoping you can extend the model, but for
      // most uses you'll just inspect the name.
      Def("get", Nil, ParamRef(T))
    )
  )

  // ===== Higher-kinded example =====

  // type F[G[_], A] = G[A]
  val G = TypeParam("G", 0)
  val fId: TypeId[AnyKind] = alias[AnyKind](
    name       = "F",
    owner      = pkgMyApp,
    typeParams = List(G, A),
    aliased    = Applied(
      tycon = ParamRef(G),  // G is itself a type constructor
      args  = List(ParamRef(A))
    )
  )

  // ===== Singleton and constant types =====

  // 42 (literal type)
  val fortyTwoType: TypeRepr = Constant(42)

  // "hello" (literal type)
  val helloType: TypeRepr = Constant("hello")

  // myObject.type
  val myObjectSingleton: TypeRepr = Singleton(
    TermPath(List(TermPath.Package("myapp"), TermPath.Term("myObject")))
  )

  // ===== Complex types =====

  // Option[List[String]]
  val optionListStringType: TypeRepr =
    Applied(Ref(optionId), List(Applied(Ref(listId), List(stringType))))

  // Map[Email, List[Age]]
  val emailToAgesType: TypeRepr =
    Applied(
      Ref(mapId),
      List(
        Ref(emailId),
        Applied(Ref(listId), List(Ref(ageId)))
      )
    )

  // (Int, String) => Boolean
  val intStringToBoolType: TypeRepr =
    Function(List(intType, stringType), booleanType)

  // String & { def length: Int }
  val stringWithLengthType: TypeRepr =
    Intersection(
      stringType,
      Structural(Nil, List(Def("length", Nil, intType)))
    )

  // ===== Utility: substitute type parameters =====

  def substitute(
    repr: TypeRepr,
    substitutions: Map[TypeParam, TypeRepr]
  ): TypeRepr =
    repr match {
      case ParamRef(param) =>
        substitutions.getOrElse(param, repr)

      case Ref(_) =>
        repr

      case Applied(tycon, args) =>
        Applied(
          substitute(tycon, substitutions),
          args.map(substitute(_, substitutions))
        )

      case Structural(parents, members) =>
        Structural(
          parents.map(substitute(_, substitutions)),
          members.map(substituteMember(_, substitutions))
        )

      case Intersection(l, r) =>
        Intersection(
          substitute(l, substitutions),
          substitute(r, substitutions)
        )

      case Union(l, r) =>
        Union(
          substitute(l, substitutions),
          substitute(r, substitutions)
        )

      case Tuple(elems) =>
        Tuple(elems.map(substitute(_, substitutions)))

      case Function(params, result) =>
        Function(
          params.map(substitute(_, substitutions)),
          substitute(result, substitutions)
        )

      case Singleton(_) | Constant(_) | AnyType | NothingType =>
        repr
    }

  private def substituteMember(
    m: Member,
    substitutions: Map[TypeParam, TypeRepr]
  ): Member =
    m match {
      case Val(name, tpe, isVar) =>
        Val(name, substitute(tpe, substitutions), isVar)

      case Def(name, paramLists, result) =>
        Def(
          name,
          paramLists.map(_.map { p => Param(p.name, substitute(p.tpe, substitutions)) }),
          substitute(result, substitutions)
        )

      case TypeMember(name, typeParams, lower, upper) =>
        TypeMember(
          name,
          typeParams,
          lower.map(substitute(_, substitutions)),
          upper.map(substitute(_, substitutions))
        )
    }

  // Get underlying type for alias/opaque with substitution
  def underlyingType(
    id: TypeId[_],
    args: List[TypeRepr]
  ): Option[TypeRepr] = id match {
    case TypeId.Alias(_, _, typeParams, aliased) =>
      val subs = typeParams.zip(args).toMap
      Some(substitute(aliased, subs))

    case TypeId.Opaque(_, _, typeParams, representation) =>
      val subs = typeParams.zip(args).toMap
      Some(substitute(representation, subs))

    case _ =>
      None
  }

  // Examples:
  // underlyingType(ageId, Nil)                  => Some(Int)
  // underlyingType(myListId, List(intType))     => Some(List[Int])
  // underlyingType(stringMapId, List(intType))  => Some(Map[String, Int])
  // underlyingType(emailId, Nil)                => Some(String)

  // ===== Type safety via phantom types =====

  def processList(id: TypeId[List]): String =
    s"Processing list type constructor: ${id.fullName}"

  def processScalar[A](id: TypeId[A]): String =
    s"Processing scalar type: ${id.fullName}"

  // These compile:
  val _x: String = processList(listId)
  val _y: String = processList(myListId)     // MyList is an alias for List
  val _z: String = processList(safeListId)   // SafeList is opaque over List

  val _s1: String = processScalar(intId)
  val _s2: String = processScalar(ageId)     // Age is an alias for Int
  val _s3: String = processScalar(emailId)   // Email is opaque over String

  // These would NOT compile:
  // processList(intId)     // Type mismatch
  // processScalar(listId)  // Type mismatch
}
```
