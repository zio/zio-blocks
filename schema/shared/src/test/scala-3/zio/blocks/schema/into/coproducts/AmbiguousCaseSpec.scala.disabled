package zio.blocks.schema.into.coproducts

import zio.test._
import zio.test.Assertion._
import zio.blocks.schema._

object AmbiguousCaseSpec extends ZIOSpecDefault {

  def spec = suite("AmbiguousCaseSpec")(
    suite("Missing Target Case")(
      test("should fail to derive when source has case not in target (Known Limitation: Currently fails at runtime)") {
        typeCheck {
          """
          object SourceTypes {
            sealed trait Color
            case object Red   extends Color
            case object Blue  extends Color
            case object Green extends Color
          }
          import SourceTypes._

          object TargetTypes {
            sealed trait Color
            case object Red  extends Color
            case object Blue extends Color
          }
          import TargetTypes._

          Into.derived[SourceTypes.Color, TargetTypes.Color]
          """
        }.map(
          // Known Limitation: The macro currently does NOT fail at compile-time for missing cases.
          // It will fail at runtime instead. This test documents the current behavior.
          // TODO: Update this test when compile-time checking is implemented.
          assert(_)(
            isRight // Currently compiles successfully, fails at runtime
          )
        )
      },
      test("should fail to derive when source enum has more cases than target (Known Limitation: Currently fails at runtime)") {
        typeCheck {
          """
          enum SourceStatus {
            case Active
            case Inactive
            case Pending
            case Canceled
          }

          enum TargetStatus {
            case Active
            case Inactive
          }

          Into.derived[SourceStatus, TargetStatus]
          """
        }.map(
          // Known Limitation: The macro currently does NOT fail at compile-time for missing cases.
          assert(_)(
            isRight // Currently compiles successfully, fails at runtime
          )
        )
      },
      test("should fail to derive when source has case class subtype not in target (Known Limitation: Currently fails at runtime)") {
        typeCheck {
          """
          object SourceTypes {
            sealed trait Event
            case class Created(id: Int)    extends Event
            case class Deleted(id: String) extends Event
            case class Updated(id: Long)  extends Event
          }
          import SourceTypes._

          object TargetTypes {
            sealed trait Event
            case class Created(id: Int)    extends Event
            case class Deleted(id: String) extends Event
          }
          import TargetTypes._

          Into.derived[SourceTypes.Event, TargetTypes.Event]
          """
        }.map(
          // Known Limitation: The macro currently does NOT fail at compile-time for missing cases.
          assert(_)(
            isRight // Currently compiles successfully, fails at runtime
          )
        )
      }
    ),
    suite("Payload Mismatch (Non-Coercible)")(
      test("should fail to derive when case class payload types are incompatible") {
        typeCheck {
          """
          object SourceTypes {
            sealed trait Result
            case class Success(value: String) extends Result
          }
          import SourceTypes._

          object TargetTypes {
            sealed trait Result
            case class Success(value: Int) extends Result
          }
          import TargetTypes._

          Into.derived[SourceTypes.Result, TargetTypes.Result]
          """
        }.map(
          assert(_)(
            isLeft(
              containsString("Cannot derive") ||
                containsString("String") ||
                containsString("Int") ||
                containsString("not coercible") ||
                containsString("No implicit instance found")
            )
          )
        )
      },
      test("should fail to derive when case class has different number of fields (Known Limitation: Currently fails at runtime)") {
        typeCheck {
          """
          object SourceTypes {
            sealed trait Event
            case class Created(id: Int, name: String) extends Event
          }
          import SourceTypes._

          object TargetTypes {
            sealed trait Event
            case class Created(id: Int) extends Event
          }
          import TargetTypes._

          Into.derived[SourceTypes.Event, TargetTypes.Event]
          """
        }.map(
          // Known Limitation: The macro currently does NOT fail at compile-time for arity mismatches in nested case classes.
          assert(_)(
            isRight // Currently compiles successfully, fails at runtime
          )
        )
      },
      test("should fail to derive when case class field types don't match (non-coercible)") {
        typeCheck {
          """
          object SourceTypes {
            sealed trait Result
            case class Success(value: Boolean) extends Result
          }
          import SourceTypes._

          object TargetTypes {
            sealed trait Result
            case class Success(value: String) extends Result
          }
          import TargetTypes._

          Into.derived[SourceTypes.Result, TargetTypes.Result]
          """
        }.map(
          assert(_)(
            isLeft(
              containsString("Cannot derive") ||
                containsString("Boolean") ||
                containsString("String") ||
                containsString("not coercible") ||
                containsString("No implicit instance found")
            )
          )
        )
      }
    ),
    suite("Mixed Case Types")(
      test("should fail when source has case object but target has case class with same name") {
        typeCheck {
          """
          object SourceTypes {
            sealed trait Event
            case object Updated extends Event
          }
          import SourceTypes._

          object TargetTypes {
            sealed trait Event
            case class Updated(id: Int) extends Event
          }
          import TargetTypes._

          Into.derived[SourceTypes.Event, TargetTypes.Event]
          """
        }.map(
          assert(_)(
            isLeft(
              containsString("Cannot derive") ||
                containsString("Updated") ||
                containsString("type mismatch") ||
                containsString("No matching subtypes found")
            )
          )
        )
      },
      test("should fail when source has case class but target has case object with same name") {
        typeCheck {
          """
          object SourceTypes {
            sealed trait Event
            case class Updated(id: Int) extends Event
          }
          import SourceTypes._

          object TargetTypes {
            sealed trait Event
            case object Updated extends Event
          }
          import TargetTypes._

          Into.derived[SourceTypes.Event, TargetTypes.Event]
          """
        }.map(
          assert(_)(
            isLeft(
              containsString("Cannot derive") ||
                containsString("Updated") ||
                containsString("type mismatch") ||
                containsString("No matching subtypes found")
            )
          )
        )
      }
    )
  )
}

