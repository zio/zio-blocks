# Issue #462: JSON Schema Support

**Captured**: 2026-01-24
**URL**: https://github.com/zio/zio-blocks/issues/462
**State**: OPEN
**Author**: jdegoes
**Labels**: $2k, Bounty

## Description

# Add JSON Schema 2020-12 Support

## Overview

This ticket adds first-class [JSON Schema 2020-12](https://json-schema.org/draft/2020-12/json-schema-core) support to ZIO Blocks, enabling:

1. A `JsonSchema` ADT that precisely models the JSON Schema specification
2. Bidirectional conversion between `Schema[A]` and `JsonSchema`
3. Runtime validation of `Json` values against `JsonSchema`
4. Schema extraction from `JsonBinaryCodec[A]` instances

This follows the established pattern used by `AvroBinaryCodec`, which exposes an `avroSchema: AvroSchema` field for each codec instance.

---

## Background: ZIO Blocks Architecture

### Core Types

| Type | Purpose |
|------|---------|
| `Schema[A]` | Reified structure of Scala type `A` with construction/deconstruction capabilities |
| `Reflect[F, A]` | The underlying ADT representing type structure. `Schema[A]` wraps `Reflect[Binding, A]` |
| `DynamicValue` | A semi-structured representation (superset of JSON) that any `Schema[A]` can convert to/from |
| `Json` | The JSON AST in `zio.blocks.schema.json` |
| `JsonBinaryCodec[A]` | Typeclass for JSON serialization, derived from `Schema[A]` via `JsonBinaryCodecDeriver` |

### How Derivation Works
```scala
case class Person(name: String, age: Int)
object Person {
  implicit val schema: Schema[Person] = Schema.derived
}

// Derive a JSON codec from the schema:
val codec: JsonBinaryCodec[Person] = Schema[Person].derive(JsonFormat.deriver)

// Or use encode/decode directly (caches the codec):
Schema[Person].encode(JsonFormat)(buffer)(person)
Schema[Person].decode(JsonFormat)(buffer)
```

### Key Insight: DynamicValue as the Bridge

`Schema[A]` can convert any `A` to `DynamicValue` and back. Since `DynamicValue` is structurally similar to JSON, and `Json.fromDynamicValue` / `Json.toDynamicValue` exist, we can create `Schema[Json]` by wrapping `Schema[DynamicValue]`.

This is how `Schema.fromJsonSchema` will work: it wraps `Schema[DynamicValue]` with validation logic that checks the `JsonSchema` constraints.

### Metadata That Maps to JSON Schema

| ZIO Blocks Type | JSON Schema Equivalent |
|-----------------|------------------------|
| `TypeName[A]` | Can be stored in `$id` or custom extension for round-trip |
| `Doc` | `title` / `description` |
| `Validation[A]` | `minimum`, `maximum`, `minLength`, `maxLength`, `pattern`, etc. |
| `Modifier.rename` | Affects property names |
| `Modifier.alias` | Could map to extension for alternative names |
| `Modifier.transient` | Field excluded from schema |
| `Modifier.config` | Extensible metadata (e.g., `"json-schema.format" -> "email"`) |
| `DiscriminatorKind` | Affects `oneOf`/`anyOf` structure and `discriminator` keyword |
| `NameMapper` | Applied to field/case names during schema generation |

---

## Requirements

### 1. Create `JsonSchema` ADT

Create a new sealed trait `JsonSchema` in `zio.blocks.schema.json` that models JSON Schema 2020-12.

**Location:** `schema/shared/src/main/scala/zio/blocks/schema/json/JsonSchema.scala`

The ADT must support:
- Boolean schemas (`true` accepts all, `false` rejects all)
- Full schema objects with all standard vocabularies (core, applicator, validation, format, content, metadata)
- Round-trip JSON serialization (`toJson` / `fromJson`)
- Validation (`check` method returning accumulated errors)
- Combinators (`&&` for allOf, `||` for anyOf, `!` for not)

### 2. Add `toJsonSchema` to `JsonBinaryCodec[A]`

**Location:** `schema/shared/src/main/scala/zio/blocks/schema/json/JsonBinaryCodec.scala`
```scala
abstract class JsonBinaryCodec[A](...) extends BinaryCodec[A] {
  def toJsonSchema: JsonSchema
}
```

### 3. Add `toJsonSchema` to `Schema[A]`

**Location:** `schema/shared/src/main/scala/zio/blocks/schema/Schema.scala`
```scala
final case class Schema[A](reflect: Reflect.Bound[A]) {
  def toJsonSchema: JsonSchema
}
```

### 4. Add `Schema.fromJsonSchema`

**Location:** `schema/shared/src/main/scala/zio/blocks/schema/Schema.scala`
```scala
object Schema extends SchemaCompanionVersionSpecific {
  def fromJsonSchema(jsonSchema: JsonSchema): Schema[Json]
}
```

### 5. Add `Schema[Json]` Instance

### 6. Update `Json.check` and `Json.conforms`

Change parameter type from `Json` to `JsonSchema`.

### 7. Add `Schema[JsonSchema]` Instance

---

## Validation to JsonSchema Mapping

| `Validation[A]` | JSON Schema Keywords |
|-----------------|---------------------|
| `Validation.None` | (no constraints) |
| `Validation.Numeric.Positive` | `exclusiveMinimum: 0` |
| `Validation.Numeric.NonNegative` | `minimum: 0` |
| `Validation.Numeric.Negative` | `exclusiveMaximum: 0` |
| `Validation.Numeric.NonPositive` | `maximum: 0` |
| `Validation.Numeric.Range(min, max)` | `minimum` / `maximum` |
| `Validation.Numeric.Set(values)` | `enum: [...]` |
| `Validation.String.NonEmpty` | `minLength: 1` |
| `Validation.String.Empty` | `maxLength: 0` |
| `Validation.String.Length(min, max)` | `minLength` / `maxLength` |
| `Validation.String.Pattern(regex)` | `pattern` |

---

## Modifier.config Keys

| Key | Effect |
|-----|--------|
| `json-schema.format` | Sets `format` keyword |
| `json-schema.deprecated` | Sets `deprecated: true` |
| `json-schema.title` | Overrides `title` |
| `json-schema.description` | Overrides `description` |

---

## Files to Create or Modify

| File | Action |
|------|--------|
| `schema/shared/src/main/scala/zio/blocks/schema/json/JsonSchema.scala` | **CREATE** |
| `schema/shared/src/main/scala/zio/blocks/schema/json/JsonBinaryCodec.scala` | **MODIFY** |
| `schema/shared/src/main/scala/zio/blocks/schema/json/JsonBinaryCodecDeriver.scala` | **MODIFY** |
| `schema/shared/src/main/scala/zio/blocks/schema/Schema.scala` | **MODIFY** |
| `schema/shared/src/main/scala/zio/blocks/schema/json/Json.scala` | **MODIFY** |

---

## Required Test Suites

1. `JsonSchemaSpec` - Core ADT Tests
2. `JsonSchemaRoundTripSpec` - Serialization Tests
3. `JsonBinaryCodecToJsonSchemaSpec` - Codec Schema Extraction Tests
4. `SchemaToJsonSchemaSpec` - Schema Conversion Tests
5. `SchemaFromJsonSchemaSpec` - Schema Construction Tests
6. `JsonCheckSpec` - Json.check/conforms Tests
7. `JsonSchemaCombinatorSpec` - Combinator Tests

---

## Acceptance Criteria

- [ ] All test suites pass
- [ ] `JsonSchema` ADT covers JSON Schema 2020-12 core, applicator, validation, format, content, and metadata vocabularies
- [ ] `JsonSchema#toJson` produces valid JSON Schema documents
- [ ] `JsonSchema.fromJson` parses valid JSON Schema documents
- [ ] `JsonSchema#check` validates JSON values with accumulated errors
- [ ] `JsonBinaryCodec[A].toJsonSchema` produces accurate schemas reflecting codec configuration
- [ ] `Schema[A].toJsonSchema` works for all derivable types
- [ ] `Schema.fromJsonSchema` produces a working `Schema[Json]` with validation
- [ ] `Json#check` and `Json#conforms` work with the new `JsonSchema` parameter type
- [ ] `Validation[A]` constraints map to appropriate JSON Schema keywords
- [ ] `Doc` maps to `description`
- [ ] `Modifier.rename`, `Modifier.transient`, and `Modifier.config` are respected
- [ ] Code follows existing project style and conventions
- [ ] No new dependencies are introduced
