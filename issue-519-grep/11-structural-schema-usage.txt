schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/TuplesSpec.scala:1:package zio.blocks.schema.structural.common
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/TuplesSpec.scala:6:/** Tests for tuple to structural type conversion. */
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/TuplesSpec.scala:10:    test("tuple2 converts to structural with correct type name") {
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/TuplesSpec.scala:12:      val structural = schema.structural
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/TuplesSpec.scala:13:      val typeName   = structural.reflect.typeName.name
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/TuplesSpec.scala:18:      val structural = schema.structural
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/TuplesSpec.scala:19:      val fieldNames = structural.reflect match {
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/CollectionsSpec.scala:1:package zio.blocks.schema.structural.common
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/CollectionsSpec.scala:6:/** Tests for collections in structural types. */
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/CollectionsSpec.scala:13:    test("case class with List field converts to structural") {
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/CollectionsSpec.scala:15:      val structural = schema.structural
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/CollectionsSpec.scala:16:      val typeName   = structural.reflect.typeName.name
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/CollectionsSpec.scala:19:    test("case class with Map field converts to structural") {
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/CollectionsSpec.scala:21:      val structural = schema.structural
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/CollectionsSpec.scala:22:      val typeName   = structural.reflect.typeName.name
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/LargeProductSpec.scala:1:package zio.blocks.schema.structural.common
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/LargeProductSpec.scala:6:/** Tests for large product types (>22 fields) to structural conversion. */
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/LargeProductSpec.scala:40:      val structural = schema.structural
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/LargeProductSpec.scala:41:      val numFields  = structural.reflect match {
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/LargeProductSpec.scala:49:      val structural = schema.structural
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/LargeProductSpec.scala:50:      val fieldNames = structural.reflect match {
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/IntoIntegrationSpec.scala:1:package zio.blocks.schema.structural.common
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/IntoIntegrationSpec.scala:6:/** Tests for Into integration with structural types. */
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/IntoIntegrationSpec.scala:13:    test("nominal to structural via Into") {
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/IntoIntegrationSpec.scala:19:    test("nominal to structural preserves data") {
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/SimpleProductSpec.scala:1:package zio.blocks.schema.structural.common
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/SimpleProductSpec.scala:6:/** Tests for simple product type to structural conversion. */
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/SimpleProductSpec.scala:13:    test("case class converts to structural with correct type name") {
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/SimpleProductSpec.scala:15:      val structural = schema.structural
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/SimpleProductSpec.scala:16:      val typeName   = structural.reflect.typeName.name
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/SimpleProductSpec.scala:19:    test("structural schema has correct field names") {
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/SimpleProductSpec.scala:21:      val structural = schema.structural
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/SimpleProductSpec.scala:22:      val fieldNames = structural.reflect match {
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/SimpleProductSpec.scala:28:    test("direct structural type derivation works") {
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/AsIntegrationSpec.scala:1:package zio.blocks.schema.structural.common
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/AsIntegrationSpec.scala:6:/** Tests for As integration with structural types. */
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/AsIntegrationSpec.scala:13:    test("Into from Person to structural works") {
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/AsIntegrationSpec.scala:19:    test("structural schema round-trip via DynamicValue") {
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/TypeNameNormalizationSpec.scala:1:package zio.blocks.schema.structural.common
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/TypeNameNormalizationSpec.scala:6:/** Tests for type name normalization in structural types. */
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/TypeNameNormalizationSpec.scala:30:    test("nominal and direct structural produce same type name") {
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/TypeNameNormalizationSpec.scala:32:      val structuralSchema = nominalSchema.structural
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/TypeNameNormalizationSpec.scala:34:      assertTrue(structuralSchema.reflect.typeName.name == directSchema.reflect.typeName.name)
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/EmptyProductSpec.scala:1:package zio.blocks.schema.structural.common
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/EmptyProductSpec.scala:6:/** Tests for empty product types to structural conversion. */
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/EmptyProductSpec.scala:13:    test("empty case class converts to structural") {
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/EmptyProductSpec.scala:15:      val structural = schema.structural
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/EmptyProductSpec.scala:16:      val typeName   = structural.reflect.typeName.name
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/EmptyProductSpec.scala:19:    test("case object converts to structural") {
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/EmptyProductSpec.scala:21:      val structural = schema.structural
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/EmptyProductSpec.scala:22:      val typeName   = structural.reflect.typeName.name
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/EmptyProductSpec.scala:25:    test("empty structural has zero fields") {
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/EmptyProductSpec.scala:27:      val structural = schema.structural
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/EmptyProductSpec.scala:28:      val numFields  = structural.reflect match {
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/SingleFieldSpec.scala:1:package zio.blocks.schema.structural.common
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/SingleFieldSpec.scala:6:/** Tests for single-field product types to structural conversion. */
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/SingleFieldSpec.scala:15:      val structural = schema.structural
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/SingleFieldSpec.scala:16:      val typeName   = structural.reflect.typeName.name
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/SingleFieldSpec.scala:21:      val structural = schema.structural
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/SingleFieldSpec.scala:22:      val typeName   = structural.reflect.typeName.name
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/SingleFieldSpec.scala:25:    test("single field structural has one field") {
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/SingleFieldSpec.scala:27:      val structural = schema.structural
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/SingleFieldSpec.scala:28:      val numFields  = structural.reflect match {
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/NestedProductSpec.scala:1:package zio.blocks.schema.structural.common
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/NestedProductSpec.scala:6:/** Tests for nested product types to structural conversion. */
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/NestedProductSpec.scala:15:      val structural = schema.structural
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/NestedProductSpec.scala:16:      val typeName   = structural.reflect.typeName.name
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/NestedProductSpec.scala:19:    test("structural schema preserves field names") {
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/NestedProductSpec.scala:21:      val structural = schema.structural
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/common/NestedProductSpec.scala:22:      val fieldNames = structural.reflect match {
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/UnionTypesSpec.scala:1:package zio.blocks.schema.structural
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/UnionTypesSpec.scala:7: * Tests for sealed trait to structural union type conversion (Scala 3 only).
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/UnionTypesSpec.scala:24:    test("sealed trait with case classes converts to structural") {
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/UnionTypesSpec.scala:26:      val structural = schema.structural
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/UnionTypesSpec.scala:27:      assertTrue(structural != null)
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/UnionTypesSpec.scala:29:    test("sealed trait with case objects converts to structural") {
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/UnionTypesSpec.scala:31:      val structural = schema.structural
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/UnionTypesSpec.scala:32:      assertTrue(structural != null)
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/UnionTypesSpec.scala:34:    test("structural type name contains all cases with Tag fields") {
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/UnionTypesSpec.scala:36:      val structural = schema.structural
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/UnionTypesSpec.scala:37:      val typeName   = structural.reflect.typeName.name
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/PureStructuralTypeSpec.scala:1:package zio.blocks.schema.structural
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/PureStructuralTypeSpec.scala:6:/** Tests for pure structural type Schema derivation (JVM only). */
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/PureStructuralTypeSpec.scala:12:    test("pure structural type derives schema") {
schema/jvm/src/test/scala-3/zio/blocks/schema/structural/PureStructuralTypeSpec.scala:16:    test("pure structural type schema has correct field names") {
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/MutualRecursionErrorSpec.scala:1:package zio.blocks.schema.structural.errors
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/MutualRecursionErrorSpec.scala:7: * converting to structural.
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/MutualRecursionErrorSpec.scala:16: * Cannot generate structural type for recursive type MyType.
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/MutualRecursionErrorSpec.scala:30:      test("Node-Edge mutual recursion fails to convert to structural") {
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/MutualRecursionErrorSpec.scala:39:          schema.structural
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/MutualRecursionErrorSpec.scala:45:      test("Parent-Child mutual recursion fails to convert to structural") {
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/MutualRecursionErrorSpec.scala:54:          schema.structural
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/MutualRecursionErrorSpec.scala:69:          schemaA.structural
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/MutualRecursionErrorSpec.scala:84:          schemaB.structural
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/MutualRecursionErrorSpec.scala:102:          schema.structural
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/MutualRecursionErrorSpec.scala:118:          schema.structural
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/MutualRecursionErrorSpec.scala:135:          schema.structural
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/MutualRecursionErrorSpec.scala:163:          schema.structural
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/MutualRecursionErrorSpec.scala:179:          schema.structural
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/MutualRecursionErrorSpec.scala:196:          schema.structural
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/RecursiveTypeErrorSpec.scala:1:package zio.blocks.schema.structural.errors
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/RecursiveTypeErrorSpec.scala:7: * structural types.
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/RecursiveTypeErrorSpec.scala:10: * Recursive types cannot be represented as structural types because Scala does
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/RecursiveTypeErrorSpec.scala:17: * Cannot generate structural type for recursive type MyType.
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/RecursiveTypeErrorSpec.scala:27:      test("direct recursive type (LinkedList) fails to convert to structural") {
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/RecursiveTypeErrorSpec.scala:35:          schema.structural
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/RecursiveTypeErrorSpec.scala:49:      test("self-referencing type fails to convert to structural") {
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/RecursiveTypeErrorSpec.scala:57:          schema.structural
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/RecursiveTypeErrorSpec.scala:65:      test("list-wrapped recursive type (Tree) fails to convert to structural") {
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/RecursiveTypeErrorSpec.scala:73:          schema.structural
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/RecursiveTypeErrorSpec.scala:87:      test("option-wrapped recursive type fails to convert to structural") {
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/RecursiveTypeErrorSpec.scala:95:          schema.structural
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/RecursiveTypeErrorSpec.scala:101:      test("set-wrapped recursive type fails to convert to structural") {
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/RecursiveTypeErrorSpec.scala:109:          schema.structural
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/RecursiveTypeErrorSpec.scala:115:      test("vector-wrapped recursive type fails to convert to structural") {
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/RecursiveTypeErrorSpec.scala:123:          schema.structural
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/RecursiveTypeErrorSpec.scala:139:          schema.structural
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/RecursiveTypeErrorSpec.scala:161:          schema.structural
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/RecursiveTypeErrorSpec.scala:172:      test("non-recursive case class converts to structural successfully") {
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/RecursiveTypeErrorSpec.scala:180:          schema.structural
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/RecursiveTypeErrorSpec.scala:195:          schema.structural
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/RecursiveTypeErrorSpec.scala:209:          schema.structural
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/UnsupportedTypeErrorSpec.scala:1:package zio.blocks.schema.structural.errors
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/UnsupportedTypeErrorSpec.scala:32:      test("simple case class converts to structural") {
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/UnsupportedTypeErrorSpec.scala:40:          schema.structural
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/UnsupportedTypeErrorSpec.scala:46:      test("case class with all primitives converts to structural") {
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/UnsupportedTypeErrorSpec.scala:57:          schema.structural
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/UnsupportedTypeErrorSpec.scala:63:      test("case class with Option converts to structural") {
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/UnsupportedTypeErrorSpec.scala:71:          schema.structural
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/UnsupportedTypeErrorSpec.scala:77:      test("case class with List converts to structural") {
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/UnsupportedTypeErrorSpec.scala:85:          schema.structural
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/UnsupportedTypeErrorSpec.scala:91:      test("case class with Set converts to structural") {
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/UnsupportedTypeErrorSpec.scala:99:          schema.structural
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/UnsupportedTypeErrorSpec.scala:105:      test("case class with Vector converts to structural") {
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/UnsupportedTypeErrorSpec.scala:113:          schema.structural
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/UnsupportedTypeErrorSpec.scala:119:      test("case class with Map converts to structural") {
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/UnsupportedTypeErrorSpec.scala:127:          schema.structural
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/UnsupportedTypeErrorSpec.scala:133:      test("nested case class converts to structural") {
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/UnsupportedTypeErrorSpec.scala:142:          schema.structural
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/UnsupportedTypeErrorSpec.scala:148:      test("deeply nested case class converts to structural") {
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/UnsupportedTypeErrorSpec.scala:159:          schema.structural
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/UnsupportedTypeErrorSpec.scala:165:      test("empty case class converts to structural") {
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/UnsupportedTypeErrorSpec.scala:173:          schema.structural
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/UnsupportedTypeErrorSpec.scala:179:      test("case object converts to structural") {
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/UnsupportedTypeErrorSpec.scala:187:          schema.structural
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/UnsupportedTypeErrorSpec.scala:195:      test("25 field case class converts to structural") {
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/UnsupportedTypeErrorSpec.scala:209:          schema.structural
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/UnsupportedTypeErrorSpec.scala:215:      test("30 field case class with mixed types converts to structural") {
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/UnsupportedTypeErrorSpec.scala:230:          schema.structural
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/UnsupportedTypeErrorSpec.scala:238:      test("tuple2 converts to structural") {
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/UnsupportedTypeErrorSpec.scala:244:          schema.structural
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/UnsupportedTypeErrorSpec.scala:250:      test("tuple3 converts to structural") {
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/UnsupportedTypeErrorSpec.scala:256:          schema.structural
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/UnsupportedTypeErrorSpec.scala:262:      test("nested tuple converts to structural") {
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/UnsupportedTypeErrorSpec.scala:268:          schema.structural
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/UnsupportedTypeErrorSpec.scala:274:      test("tuple with case class converts to structural") {
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/UnsupportedTypeErrorSpec.scala:281:          schema.structural
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/UnsupportedTypeErrorSpec.scala:291:      test("case class with Either field converts to structural") {
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/UnsupportedTypeErrorSpec.scala:299:          schema.structural
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/UnsupportedTypeErrorSpec.scala:305:      test("case class with nested Option[List[T]] converts to structural") {
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/UnsupportedTypeErrorSpec.scala:313:          schema.structural
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/UnsupportedTypeErrorSpec.scala:319:      test("case class with Map[String, List[T]] converts to structural") {
schema/jvm/src/test/scala/zio/blocks/schema/structural/errors/UnsupportedTypeErrorSpec.scala:327:          schema.structural
schema/jvm/src/test/scala/zio/blocks/schema/into/structural/ProductToStructuralSpec.scala:1:package zio.blocks.schema.into.structural
schema/jvm/src/test/scala/zio/blocks/schema/into/structural/ProductToStructuralSpec.scala:9: * Tests for case class to structural type conversions in Into derivation.
schema/jvm/src/test/scala/zio/blocks/schema/into/structural/ProductToStructuralSpec.scala:11: * These tests verify that Into can convert from case classes to structural
schema/jvm/src/test/scala/zio/blocks/schema/into/structural/ProductToStructuralSpec.scala:12: * types. The case class must have all the members required by the structural
schema/jvm/src/test/scala/zio/blocks/schema/into/structural/ProductToStructuralSpec.scala:30:      test("converts case class to structural with same fields") {
schema/jvm/src/test/scala/zio/blocks/schema/into/structural/ProductToStructuralSpec.scala:56:      test("converts case class to structural with fewer fields") {
schema/jvm/src/test/scala/zio/blocks/schema/into/structural/ProductToStructuralSpec.scala:68:      test("converts case class to structural with single field from many") {
schema/jvm/src/test/scala/zio/blocks/schema/into/structural/ProductToStructuralSpec.scala:82:      test("converts case class with all fields to matching structural") {
schema/jvm/src/test/scala/zio/blocks/schema/into/structural/ProductToStructuralSpec.scala:96:      test("case class to structural to case class") {
schema/jvm/src/test/scala/zio/blocks/schema/into/structural/StructuralTypeSourceSpec.scala:1:package zio.blocks.schema.into.structural
schema/jvm/src/test/scala/zio/blocks/schema/into/structural/StructuralTypeSourceSpec.scala:8: * Tests for structural type as source in Into derivation.
schema/jvm/src/test/scala/zio/blocks/schema/into/structural/StructuralTypeSourceSpec.scala:13: * These tests verify that Into can convert from structural types to case
schema/jvm/src/test/scala/zio/blocks/schema/into/structural/StructuralTypeSourceSpec.scala:41:      test("converts structural type with matching fields") {
schema/jvm/src/test/scala/zio/blocks/schema/into/structural/StructuralTypeSourceSpec.scala:48:      test("converts structural type with single field") {
schema/jvm/src/test/scala/zio/blocks/schema/into/structural/StructuralTypeSourceSpec.scala:55:      test("converts structural type with three fields") {
schema/jvm/src/test/scala/zio/blocks/schema/into/structural/StructuralTypeSourceSpec.scala:64:      test("converts structural with extra fields (drops extras)") {
schema/jvm/src/test/scala/zio/blocks/schema/into/structural/StructuralTypeSourceSpec.scala:73:      test("converts structural with fewer fields using defaults") {
schema/jvm/src/test/scala/zio/blocks/schema/into/structural/StructuralTypeSourceSpec.scala:82:      test("converts structural with fewer fields using None for optional") {
schema/jvm/src/test/scala/zio/blocks/schema/into/structural/StructuralTypeSourceSpec.scala:91:      test("structural to same structural") {
schema/jvm/src/test/scala/zio/blocks/schema/into/structural/StructuralTypeSourceSpec.scala:93:        // Note: structural types can be used as both source and target
schema/jvm/src/test/scala/zio/blocks/schema/into/structural/StructuralTypeSourceSpec.scala:101:      test("chain of structural to case class conversions") {
schema/jvm/src/test/scala-2/zio/blocks/schema/structural/SumTypeErrorSpec.scala:1:package zio.blocks.schema.structural
schema/jvm/src/test/scala-2/zio/blocks/schema/structural/SumTypeErrorSpec.scala:8: * Sum types cannot be converted to structural types in Scala 2 because they
schema/jvm/src/test/scala-2/zio/blocks/schema/structural/SumTypeErrorSpec.scala:15:      test("sealed trait with case classes fails to convert to structural") {
schema/jvm/src/test/scala-2/zio/blocks/schema/structural/SumTypeErrorSpec.scala:25:          schema.structural
schema/jvm/src/test/scala-2/zio/blocks/schema/structural/SumTypeErrorSpec.scala:30:            result.left.exists(msg => msg.toLowerCase.contains("sum type") || msg.toLowerCase.contains("structural"))
schema/jvm/src/test/scala-2/zio/blocks/schema/structural/SumTypeErrorSpec.scala:34:      test("sealed trait with case objects fails to convert to structural") {
schema/jvm/src/test/scala-2/zio/blocks/schema/structural/SumTypeErrorSpec.scala:44:          schema.structural
schema/jvm/src/test/scala-2/zio/blocks/schema/structural/SumTypeErrorSpec.scala:50:      test("nested sealed trait fails to convert to structural") {
schema/jvm/src/test/scala-2/zio/blocks/schema/structural/SumTypeErrorSpec.scala:62:          schema.structural
schema/jvm/src/test/scala-2/zio/blocks/schema/structural/SumTypeErrorSpec.scala:80:          schema.structural
schema/jvm/src/test/scala-2/zio/blocks/schema/structural/SumTypeErrorSpec.scala:98:      test("case class converts to structural successfully") {
schema/jvm/src/test/scala-2/zio/blocks/schema/structural/SumTypeErrorSpec.scala:106:          val structural = schema.structural
schema/jvm/src/test/scala-2/zio/blocks/schema/structural/SumTypeErrorSpec.scala:107:          structural != null
schema/jvm/src/test/scala-2/zio/blocks/schema/structural/SumTypeErrorSpec.scala:113:      test("tuple converts to structural successfully") {
schema/jvm/src/test/scala-2/zio/blocks/schema/structural/SumTypeErrorSpec.scala:119:          val structural = schema.structural
schema/jvm/src/test/scala-2/zio/blocks/schema/structural/SumTypeErrorSpec.scala:120:          structural != null
schema/jvm/src/test/scala-2/zio/blocks/schema/structural/StructuralTypeSpec.scala:1:package zio.blocks.schema.structural
schema/jvm/src/test/scala-2/zio/blocks/schema/structural/StructuralTypeSpec.scala:7: * Tests for Scala 2 pure structural type derivation (JVM only).
schema/jvm/src/test/scala-2/zio/blocks/schema/structural/StructuralTypeSpec.scala:15:    test("structural type round-trips through DynamicValue") {
schema/jvm/src/test/scala-2/zio/blocks/schema/structural/StructuralTypeSpec.scala:36:    test("structural type with primitives round-trips") {
schema/jvm/src/test/scala-2/zio/blocks/schema/into/structural/StructuralTypeSpec.scala:1:package zio.blocks.schema.into.structural
schema/jvm/src/test/scala-2/zio/blocks/schema/into/structural/StructuralTypeSpec.scala:9: * JVM-only tests for structural types that require reflection.
schema/jvm/src/test/scala-2/zio/blocks/schema/into/structural/StructuralTypeSpec.scala:11: * These tests use ad-hoc structural types created with `new { def ... }` syntax
schema/jvm/src/test/scala-2/zio/blocks/schema/into/structural/StructuralTypeSpec.scala:43:      test("converts structural type to case class with matching fields") {
schema/jvm/src/test/scala-2/zio/blocks/schema/into/structural/StructuralTypeSpec.scala:50:      test("converts structural type with extra fields (subset mapping)") {
schema/jvm/src/test/scala-2/zio/blocks/schema/into/structural/StructuralTypeSpec.scala:57:      test("converts structural type with all fields") {
schema/jvm/src/test/scala-2/zio/blocks/schema/into/structural/StructuralTypeSpec.scala:64:      test("converts Point structural type to case class") {
schema/jvm/src/test/scala-2/zio/blocks/schema/into/structural/StructuralTypeSpec.scala:73:      test("structural to case class to structural") {
schema/jvm/src/test/scala-2/zio/blocks/schema/into/structural/StructuralTypeSpec.scala:90:      test("case class to structural to case class round trip") {
schema/jvm/src/test/scala-2/zio/blocks/schema/into/structural/StructuralTypeSpec.scala:103:      test("handles structural type with single field") {
schema/jvm/src/test/scala-2/zio/blocks/schema/into/structural/StructuralTypeSpec.scala:115:      test("handles structural type with numeric fields") {
schema/jvm/src/test/scala-2/zio/blocks/schema/as/structural/StructuralAsSpec.scala:1:package zio.blocks.schema.as.structural
schema/jvm/src/test/scala-2/zio/blocks/schema/as/structural/StructuralAsSpec.scala:8:/** JVM-only tests for As with pure structural types (requires reflection). */
schema/jvm/src/test/scala-2/zio/blocks/schema/as/structural/StructuralAsSpec.scala:16:      test("As between case class and pure structural type") {
schema/jvm/src/test/scala-2/zio/blocks/schema/as/structural/StructuralAsSpec.scala:69:    suite("As structural round-trip chains (JVM Only)")(
schema/shared/src/main/scala-3/zio/blocks/schema/migration/MigrationDsl.scala:30:    * IMPORTANT: we capture STRUCTURAL schemas via Schema#structural (PR
schema/shared/src/main/scala-3/zio/blocks/schema/migration/MigrationDsl.scala:169:  // structural-schema helpers (Issue #519 + PR #614/#589)
schema/shared/src/main/scala-3/zio/blocks/schema/migration/MigrationDsl.scala:172:  /** Force structural schemas (PR #614/#589 adds Schema#structural). */
schema/shared/src/main/scala-3/zio/blocks/schema/migration/MigrationDsl.scala:173:  inline def structuralSchemaOf[A](using
schema/shared/src/main/scala-3/zio/blocks/schema/migration/MigrationDsl.scala:177:    s.structural
schema/shared/src/main/scala-3/zio/blocks/schema/migration/MigrationDsl.scala:187:  // derive + copy structural shape helper
schema/shared/src/main/scala-3/zio/blocks/schema/migration/MigrationDsl.scala:190:  /** Prints `{ def ... }` so users can copy the old structural shape. */
schema/shared/src/main/scala-3/zio/blocks/schema/SchemaCompanionVersionSpecific.scala:86:    // Empty structural type {} dealiases to java.lang.Object
schema/shared/src/main/scala-3/zio/blocks/schema/SchemaCompanionVersionSpecific.scala:1242:  // NOTE: Empty structural types like `type Empty = {}` dealias to java.lang.Object.
schema/shared/src/main/scala-3/zio/blocks/schema/SchemaCompanionVersionSpecific.scala:1243:  // We now treat AnyRef as an empty structural type, which allows Schema.derived[{}] to work.
schema/shared/src/main/scala-3/zio/blocks/schema/SchemaCompanionVersionSpecific.scala:1246:    // Pure structural types require runtime reflection (JVM only)
schema/shared/src/main/scala-3/zio/blocks/schema/SchemaCompanionVersionSpecific.scala:1249:        s"""Cannot derive Schema for structural type '${tpe.show}' on ${Platform.name}.
schema/shared/src/main/scala-3/zio/blocks/schema/SchemaCompanionVersionSpecific.scala:1259:    // Handle empty structural type (no members)
schema/shared/src/main/scala-3/zio/blocks/schema/SchemaCompanionVersionSpecific.scala:1284:      // Non-empty structural type - use reflection (JVM only)
schema/shared/src/main/scala-3/zio/blocks/schema/SchemaCompanionVersionSpecific.scala:1295:      val offset     = structuralFieldOffset(memberTpe)
schema/shared/src/main/scala-3/zio/blocks/schema/SchemaCompanionVersionSpecific.scala:1384:                // Extract values from structural type using reflection
schema/shared/src/main/scala-3/zio/blocks/schema/SchemaCompanionVersionSpecific.scala:1415:  private def structuralFieldOffset(tpe: TypeRepr): RegisterOffset = {
schema/shared/src/main/scala-3/zio/blocks/schema/DerivedOptics.scala:71:   * The returned object uses structural typing, so you get compile-time type
schema/shared/src/main/scala-3/zio/blocks/schema/DerivedOptics.scala:315:    // Build the structural refinement type
schema/shared/src/main/scala-3/zio/blocks/schema/DerivedOptics.scala:376:    // Build the structural refinement type
schema/shared/src/main/scala-3/zio/blocks/schema/SchemaVersionSpecific.scala:9:   * Convert this schema to a structural type schema.
schema/shared/src/main/scala-3/zio/blocks/schema/SchemaVersionSpecific.scala:11:   * The structural type represents the "shape" of A without its nominal
schema/shared/src/main/scala-3/zio/blocks/schema/SchemaVersionSpecific.scala:12:   * identity. This enables duck typing and structural validation.
schema/shared/src/main/scala-3/zio/blocks/schema/SchemaVersionSpecific.scala:17:   * val structuralSchema: Schema[{ def name: String; def age: Int }] =
schema/shared/src/main/scala-3/zio/blocks/schema/SchemaVersionSpecific.scala:18:   *   Schema.derived[Person].structural
schema/shared/src/main/scala-3/zio/blocks/schema/SchemaVersionSpecific.scala:21:   * Note: This is JVM-only due to reflection requirements for structural types.
schema/shared/src/main/scala-3/zio/blocks/schema/SchemaVersionSpecific.scala:24:   *   Macro-generated conversion to structural representation
schema/shared/src/main/scala-3/zio/blocks/schema/SchemaVersionSpecific.scala:26:   *   Schema for the structural type corresponding to A
schema/shared/src/main/scala-3/zio/blocks/schema/SchemaVersionSpecific.scala:28:  transparent inline def structural(using ts: ToStructural[A]): Schema[ts.StructuralType] = ts(this)
schema/shared/src/main/scala-3/zio/blocks/schema/IntoVersionSpecific.scala:101:               |  - Using a case class instead of a structural type
schema/shared/src/main/scala-3/zio/blocks/schema/IntoVersionSpecific.scala:102:               |  - Using a tuple instead of a structural type
schema/shared/src/main/scala-3/zio/blocks/schema/IntoVersionSpecific.scala:103:               |  - Only using structural type conversions in JVM-only code""".stripMargin
schema/shared/src/main/scala-3/zio/blocks/schema/IntoVersionSpecific.scala:116:               |  - Using a case class instead of a structural type
schema/shared/src/main/scala-3/zio/blocks/schema/IntoVersionSpecific.scala:117:               |  - Only using structural type conversions in JVM-only code""".stripMargin
schema/shared/src/main/scala-3/zio/blocks/schema/IntoVersionSpecific.scala:394:    val structuralMembers = getStructuralMembers(aTpe)
schema/shared/src/main/scala-3/zio/blocks/schema/IntoVersionSpecific.scala:397:    // For each target field, find matching structural member (by name or unique type)
schema/shared/src/main/scala-3/zio/blocks/schema/IntoVersionSpecific.scala:400:      val matchingMember = structuralMembers.find { case (name, memberTpe) =>
schema/shared/src/main/scala-3/zio/blocks/schema/IntoVersionSpecific.scala:409:        val uniqueTypeMatches = structuralMembers.filter { case (_, memberTpe) =>
schema/shared/src/main/scala-3/zio/blocks/schema/IntoVersionSpecific.scala:424:          // No matching structural member - check for default value or Option type
schema/shared/src/main/scala-3/zio/blocks/schema/IntoVersionSpecific.scala:430:            val sourceMembers = structuralMembers.map { case (n, t) => s"$n: ${t.show}" }.mkString(", ")
schema/shared/src/main/scala-3/zio/blocks/schema/IntoVersionSpecific.scala:432:              s"""Cannot derive Into[${aTpe.show}, ${bTpe.show}]: Missing structural member
schema/shared/src/main/scala-3/zio/blocks/schema/IntoVersionSpecific.scala:434:                 |  Source structural type has: { $sourceMembers }
schema/shared/src/main/scala-3/zio/blocks/schema/IntoVersionSpecific.scala:437:                 |No matching member found in structural type for target field '${targetField.name}'.
schema/shared/src/main/scala-3/zio/blocks/schema/IntoVersionSpecific.scala:440:                 |  - Ensuring the structural type has member '${targetField.name}: ${targetField.tpe.show}'
schema/shared/src/main/scala-3/zio/blocks/schema/IntoVersionSpecific.scala:448:    // Use reflection to access structural type members (JVM only - checked in caller)
schema/shared/src/main/scala-3/zio/blocks/schema/IntoVersionSpecific.scala:452:  // Reflection-based structural type conversion (JVM only)
schema/shared/src/main/scala-3/zio/blocks/schema/IntoVersionSpecific.scala:464:                  // Get value from structural member using reflection
schema/shared/src/main/scala-3/zio/blocks/schema/IntoVersionSpecific.scala:520:    val structuralMembers = getStructuralMembers(bTpe)
schema/shared/src/main/scala-3/zio/blocks/schema/IntoVersionSpecific.scala:523:    // Validate that all structural type members exist in the source product
schema/shared/src/main/scala-3/zio/blocks/schema/IntoVersionSpecific.scala:524:    structuralMembers.foreach { case (memberName, memberTpe) =>
schema/shared/src/main/scala-3/zio/blocks/schema/IntoVersionSpecific.scala:536:             |Source type is missing member '$memberName: ${memberTpe.show}' required by the structural type.
schema/shared/src/main/scala-3/zio/blocks/schema/IntoVersionSpecific.scala:546:    // For pure structural types (JVM only - checked earlier), use a simple cast.
schema/shared/src/main/scala-3/zio/blocks/schema/ToStructuralVersionSpecific.scala:29:        s"""Cannot generate structural type for recursive type ${aTpe.show}.
schema/shared/src/main/scala-3/zio/blocks/schema/ToStructuralVersionSpecific.scala:122:    val structuralTpe = buildStructuralType(fields)
schema/shared/src/main/scala-3/zio/blocks/schema/ToStructuralVersionSpecific.scala:124:    structuralTpe.asType match {
schema/shared/src/main/scala-3/zio/blocks/schema/ToStructuralVersionSpecific.scala:149:      report.errorAndAbort("Cannot generate structural type for empty tuple")
schema/shared/src/main/scala-3/zio/blocks/schema/ToStructuralVersionSpecific.scala:152:    val structuralTpe = buildStructuralType(fields)
schema/shared/src/main/scala-3/zio/blocks/schema/ToStructuralVersionSpecific.scala:154:    structuralTpe.asType match {
schema/shared/src/main/scala-3/zio/blocks/schema/ToStructuralVersionSpecific.scala:249:   * Transform a product schema (case class) to its structural equivalent.
schema/shared/src/main/scala-3/zio/blocks/schema/ToStructuralVersionSpecific.scala:295:          s"Cannot transform non-record schema to structural type"
schema/shared/src/main/scala-3/zio/blocks/schema/ToStructuralVersionSpecific.scala:300:   * Transform a tuple schema to its structural equivalent.
schema/shared/src/main/scala-3/zio/blocks/schema/ToStructuralVersionSpecific.scala:309:          s"Cannot transform non-record schema to structural type"
schema/shared/src/main/scala-3/zio/blocks/schema/ToStructuralVersionSpecific.scala:314:   * Transform a sum type schema (sealed trait/enum) to its structural union
schema/shared/src/main/scala-3/zio/blocks/schema/ToStructuralVersionSpecific.scala:363:          s"Cannot transform non-variant schema to structural union type"
schema/shared/src/main/scala-3/zio/blocks/schema/ToStructuralVersionSpecific.scala:368:   * Generate a normalized type name for a structural type. Fields are sorted
schema/shared/src/main/scala/zio/blocks/schema/migration/Migration.scala:48:    new Migration[A, B](program, tsa, tsb, sa.structural, sb.structural)
schema/shared/src/main/scala/zio/blocks/schema/Platform.scala:7: * platform. Some features (like structural types) require reflection APIs that
schema/shared/src/main/scala/zio/blocks/schema/ToStructural.scala:4: * Type class for converting nominal schemas to structural schemas.
schema/shared/src/main/scala/zio/blocks/schema/ToStructural.scala:7: * generates the corresponding structural type and provides a conversion method.
schema/shared/src/main/scala/zio/blocks/schema/ToStructural.scala:14: * val structuralSchema: Schema[{ def name: String; def age: Int }] = nominalSchema.structural
schema/shared/src/main/scala/zio/blocks/schema/ToStructural.scala:17: * Note: This is JVM-only due to reflection requirements for structural types.
schema/shared/src/main/scala-2/zio/blocks/schema/SchemaCompanionVersionSpecific.scala:375:    // Check if a type is a structural (refinement) type
schema/shared/src/main/scala-2/zio/blocks/schema/SchemaCompanionVersionSpecific.scala:378:      case t if t =:= definitions.AnyRefTpe                 => true // Empty structural type {}
schema/shared/src/main/scala-2/zio/blocks/schema/SchemaCompanionVersionSpecific.scala:379:      case t if t.typeSymbol.fullName == "java.lang.Object" => true // java.lang.Object treated as empty structural
schema/shared/src/main/scala-2/zio/blocks/schema/SchemaCompanionVersionSpecific.scala:383:    // Get structural type members (def name: Type refinements)
schema/shared/src/main/scala-2/zio/blocks/schema/SchemaCompanionVersionSpecific.scala:393:    // Normalize type name for structural types
schema/shared/src/main/scala-2/zio/blocks/schema/SchemaCompanionVersionSpecific.scala:417:    // Create structural type name
schema/shared/src/main/scala-2/zio/blocks/schema/SchemaCompanionVersionSpecific.scala:418:    def structuralTypeName(members: List[(String, Type)]): Tree = {
schema/shared/src/main/scala-2/zio/blocks/schema/SchemaCompanionVersionSpecific.scala:555:        // Check for structural types BEFORE isNonAbstractScalaClass
schema/shared/src/main/scala-2/zio/blocks/schema/SchemaCompanionVersionSpecific.scala:568:      // Pure structural types require runtime reflection (JVM only)
schema/shared/src/main/scala-2/zio/blocks/schema/SchemaCompanionVersionSpecific.scala:571:          s"""Cannot derive Schema for structural type '$tpe' on ${Platform.name}.
schema/shared/src/main/scala-2/zio/blocks/schema/SchemaCompanionVersionSpecific.scala:582:        // Empty structural type - derive as an empty record
schema/shared/src/main/scala-2/zio/blocks/schema/SchemaCompanionVersionSpecific.scala:583:        val tpeName = structuralTypeName(members)
schema/shared/src/main/scala-2/zio/blocks/schema/SchemaCompanionVersionSpecific.scala:606:      // Non-empty structural type - use reflection (JVM only)
schema/shared/src/main/scala-2/zio/blocks/schema/SchemaCompanionVersionSpecific.scala:611:      // Pure structural types require runtime reflection for deconstruction (JVM only)
schema/shared/src/main/scala-2/zio/blocks/schema/SchemaCompanionVersionSpecific.scala:612:      val tpeName = structuralTypeName(members)
schema/shared/src/main/scala-2/zio/blocks/schema/DerivedOptics.scala:44:   * The returned object uses structural typing, so you get compile-time type
schema/shared/src/main/scala-2/zio/blocks/schema/SchemaVersionSpecific.scala:9:   * Convert this schema to a structural type schema.
schema/shared/src/main/scala-2/zio/blocks/schema/SchemaVersionSpecific.scala:11:   * The structural type represents the "shape" of A without its nominal
schema/shared/src/main/scala-2/zio/blocks/schema/SchemaVersionSpecific.scala:12:   * identity. This enables duck typing and structural validation.
schema/shared/src/main/scala-2/zio/blocks/schema/SchemaVersionSpecific.scala:17:   * val structuralSchema: Schema[{ def name: String; def age: Int }] =
schema/shared/src/main/scala-2/zio/blocks/schema/SchemaVersionSpecific.scala:18:   *   Schema.derived[Person].structural
schema/shared/src/main/scala-2/zio/blocks/schema/SchemaVersionSpecific.scala:21:   * Note: This is JVM-only due to reflection requirements for structural types.
schema/shared/src/main/scala-2/zio/blocks/schema/SchemaVersionSpecific.scala:24:   *   Macro-generated conversion to structural representation
schema/shared/src/main/scala-2/zio/blocks/schema/SchemaVersionSpecific.scala:26:   *   Schema for the structural type corresponding to A
schema/shared/src/main/scala-2/zio/blocks/schema/SchemaVersionSpecific.scala:28:  def structural(implicit ts: ToStructural[A]): Schema[ts.StructuralType] = ts(this)
schema/shared/src/main/scala-2/zio/blocks/schema/IntoVersionSpecific.scala:1092:      val structuralMembers = getStructuralMembers(aTpe)
schema/shared/src/main/scala-2/zio/blocks/schema/IntoVersionSpecific.scala:1095:      // For each target field, find matching structural member (by name or unique type)
schema/shared/src/main/scala-2/zio/blocks/schema/IntoVersionSpecific.scala:1098:        val matchingMember = structuralMembers.find { case (name, memberTpe) =>
schema/shared/src/main/scala-2/zio/blocks/schema/IntoVersionSpecific.scala:1104:          val uniqueTypeMatches = structuralMembers.filter { case (_, memberTpe) =>
schema/shared/src/main/scala-2/zio/blocks/schema/IntoVersionSpecific.scala:1113:            // No matching structural member - check for default value or Option type
schema/shared/src/main/scala-2/zio/blocks/schema/IntoVersionSpecific.scala:1120:                s"Cannot derive Into[$aTpe, $bTpe]: no matching structural member found for field '${targetField.name}: ${targetField.tpe}'"
schema/shared/src/main/scala-2/zio/blocks/schema/IntoVersionSpecific.scala:1126:      // Generate code that accesses structural type members using reflective calls (JVM only)
schema/shared/src/main/scala-2/zio/blocks/schema/IntoVersionSpecific.scala:1130:            // Use method call for structural types
schema/shared/src/main/scala-2/zio/blocks/schema/IntoVersionSpecific.scala:1177:      val structuralMembers = getStructuralMembers(bTpe)
schema/shared/src/main/scala-2/zio/blocks/schema/IntoVersionSpecific.scala:1179:      // Validate that all structural type members exist in the source product
schema/shared/src/main/scala-2/zio/blocks/schema/IntoVersionSpecific.scala:1180:      structuralMembers.foreach { case (memberName, memberTpe) =>
schema/shared/src/main/scala-2/zio/blocks/schema/IntoVersionSpecific.scala:1187:              s"source type is missing member '$memberName: $memberTpe' required by structural type"
schema/shared/src/main/scala-2/zio/blocks/schema/IntoVersionSpecific.scala:1192:      // For pure structural types (JVM only - checked earlier), use a simple cast.
schema/shared/src/main/scala-2/zio/blocks/schema/IntoVersionSpecific.scala:1406:               |  - Using a case class instead of a structural type
schema/shared/src/main/scala-2/zio/blocks/schema/IntoVersionSpecific.scala:1407:               |  - Using a tuple instead of a structural type
schema/shared/src/main/scala-2/zio/blocks/schema/IntoVersionSpecific.scala:1408:               |  - Only using structural type conversions in JVM-only code""".stripMargin
schema/shared/src/main/scala-2/zio/blocks/schema/IntoVersionSpecific.scala:1421:               |  - Using a case class instead of a structural type
schema/shared/src/main/scala-2/zio/blocks/schema/IntoVersionSpecific.scala:1422:               |  - Only using structural type conversions in JVM-only code""".stripMargin
schema/shared/src/main/scala-2/zio/blocks/schema/ToStructuralVersionSpecific.scala:32:        s"""Cannot generate structural type for recursive type ${aTpe}.
schema/shared/src/main/scala-2/zio/blocks/schema/ToStructuralVersionSpecific.scala:100:    val structuralTpe = buildStructuralType(c)(fields)
schema/shared/src/main/scala-2/zio/blocks/schema/ToStructuralVersionSpecific.scala:105:          type StructuralType = $structuralTpe
schema/shared/src/main/scala-2/zio/blocks/schema/ToStructuralVersionSpecific.scala:106:          def apply(schema: _root_.zio.blocks.schema.Schema[$aTpe]): _root_.zio.blocks.schema.Schema[$structuralTpe] = {
schema/shared/src/main/scala-2/zio/blocks/schema/ToStructuralVersionSpecific.scala:107:            _root_.zio.blocks.schema.ToStructuralMacro.transformProductSchema[$aTpe, $structuralTpe](schema)
schema/shared/src/main/scala-2/zio/blocks/schema/ToStructuralVersionSpecific.scala:124:      c.abort(c.enclosingPosition, "Cannot generate structural type for empty tuple")
schema/shared/src/main/scala-2/zio/blocks/schema/ToStructuralVersionSpecific.scala:127:    val structuralTpe = buildStructuralType(c)(fields)
schema/shared/src/main/scala-2/zio/blocks/schema/ToStructuralVersionSpecific.scala:132:          type StructuralType = $structuralTpe
schema/shared/src/main/scala-2/zio/blocks/schema/ToStructuralVersionSpecific.scala:133:          def apply(schema: _root_.zio.blocks.schema.Schema[$aTpe]): _root_.zio.blocks.schema.Schema[$structuralTpe] = {
schema/shared/src/main/scala-2/zio/blocks/schema/ToStructuralVersionSpecific.scala:134:            _root_.zio.blocks.schema.ToStructuralMacro.transformTupleSchema[$aTpe, $structuralTpe](schema)
schema/shared/src/main/scala-2/zio/blocks/schema/ToStructuralVersionSpecific.scala:159:   * Transform a product schema (case class) to its structural equivalent. This
schema/shared/src/main/scala-2/zio/blocks/schema/ToStructuralVersionSpecific.scala:207:          s"Cannot transform non-record schema to structural type"
schema/shared/src/main/scala-2/zio/blocks/schema/ToStructuralVersionSpecific.scala:212:   * Transform a tuple schema to its structural equivalent. This is called at
schema/shared/src/main/scala-2/zio/blocks/schema/ToStructuralVersionSpecific.scala:222:          s"Cannot transform non-record schema to structural type"
schema/shared/src/main/scala-2/zio/blocks/schema/ToStructuralVersionSpecific.scala:227:   * Generate a normalized type name for a structural type. Fields are sorted
schema/shared/src/test/scala-3/zio/blocks/schema/structural/SealedTraitToUnionSpec.scala:1:package zio.blocks.schema.structural
schema/shared/src/test/scala-3/zio/blocks/schema/structural/SealedTraitToUnionSpec.scala:7: * Tests for sealed trait schema derivation and structural conversion (Scala 3
schema/shared/src/test/scala-3/zio/blocks/schema/structural/SealedTraitToUnionSpec.scala:10: * In Scala 3, sealed traits can be converted to structural types using union
schema/shared/src/test/scala-3/zio/blocks/schema/structural/EnumToUnionSpec.scala:1:package zio.blocks.schema.structural
schema/shared/src/test/scala-3/zio/blocks/schema/structural/EnumToUnionSpec.scala:7: * Tests for Scala 3 enum schema derivation and structural conversion (Scala 3
schema/shared/src/test/scala-3/zio/blocks/schema/migration/MigrationDslStructuralSpec.scala:15:  // Requires #517 structural schema derivation support
schema/shared/src/test/scala-3/zio/blocks/schema/migration/MigrationDslStructuralSpec.scala:19:    suite("MigrationDsl (structural old version)")(
schema/shared/src/test/scala-3/zio/blocks/schema/migration/MigrationDslStructuralSpec.scala:20:      test("build migration from structural old type using migrationS") {
schema/shared/src/test/scala-3/zio/blocks/schema/migration/MigrationDslStructuralSpec.scala:33:        // We need a runtime value of the structural type.
schema/shared/src/test/scala-3/zio/blocks/schema/migration/MigrationDslStructuralSpec.scala:34:        // Easiest in Scala 3 is an anonymous class implementing the structural members.
schema/shared/src/test/scala-2/zio/blocks/schema/DerivedOpticsSpec.scala:608:    test("structural type is fully refined") {
schema/native/src/test/scala/zio/blocks/schema/into/structural/StructuralTypeCompileErrorSpec.scala:1:package zio.blocks.schema.into.structural
schema/native/src/test/scala/zio/blocks/schema/into/structural/StructuralTypeCompileErrorSpec.scala:6: * Tests that structural types fail at compile time on Scala Native.
schema/native/src/test/scala/zio/blocks/schema/into/structural/StructuralTypeCompileErrorSpec.scala:12:      test("structural type to case class fails to compile") {
schema/native/src/test/scala/zio/blocks/schema/into/structural/StructuralTypeCompileErrorSpec.scala:26:            result.swap.exists(_.toLowerCase.contains("structural types require reflection"))
schema/native/src/test/scala/zio/blocks/schema/into/structural/StructuralTypeCompileErrorSpec.scala:30:      test("structural type with multiple fields fails to compile") {
schema/native/src/test/scala/zio/blocks/schema/into/structural/StructuralTypeCompileErrorSpec.scala:43:            result.swap.exists(_.toLowerCase.contains("structural types require reflection"))
schema/js/src/test/scala/zio/blocks/schema/into/structural/StructuralTypeCompileErrorSpec.scala:1:package zio.blocks.schema.into.structural
schema/js/src/test/scala/zio/blocks/schema/into/structural/StructuralTypeCompileErrorSpec.scala:6: * Tests for structural type conversions on Scala.js.
schema/js/src/test/scala/zio/blocks/schema/into/structural/StructuralTypeCompileErrorSpec.scala:14:      test("structural type to case class fails to compile") {
schema/js/src/test/scala/zio/blocks/schema/into/structural/StructuralTypeCompileErrorSpec.scala:28:            result.swap.exists(_.toLowerCase.contains("structural types require reflection"))
schema/js/src/test/scala/zio/blocks/schema/into/structural/StructuralTypeCompileErrorSpec.scala:32:      test("structural type with multiple fields fails to compile") {
schema/js/src/test/scala/zio/blocks/schema/into/structural/StructuralTypeCompileErrorSpec.scala:45:            result.swap.exists(_.toLowerCase.contains("structural types require reflection"))
